<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Software design</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.2/css/bootstrap.min.css"
          integrity="sha384-Smlep5jCw/wG7hdkwQ/Z5nLIefveQRIY9nfy6xoR1uRYBtpZgI6339F5dgvm/e9B" crossorigin="anonymous">
    <meta name="google-site-verification" content="nKBS68MBglsXyUBNGGsQ7oQZU53wrBmnye0L6Fu4jBU"/>
    <script src="https://browser.sentry-cdn.com/4.6.5/bundle.min.js" crossorigin="anonymous"></script>
    <script type="text/javascript">Sentry.init({dsn: 'https://802d42edef034b74860743196de2cac2@sentry.io/1423759'});</script>
    <link rel="stylesheet"
          href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/default.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
    <link rel="apple-touch-icon" sizes="144x144" href="/upload/img/icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/upload/img/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/upload/img/icons/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/upload/img/icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-TileImage" content="/upload/img/icons/mstile-144x144.png">
    <meta name="theme-color" content="#ffffff">
</head>
<body>
<div class="container">
    <div class="py-5 text-center">
        <h1>Software design</h1>
    </div>
</div>
<hr/>
<div class="container">
    <h2>UML</h2>
    <p>A UML diagram is a graphical representation of part of a model, typically showing a number of elements connected
        by relationships. Diagrams are one of the most expressive and appealing views of the repository; the diagram has
        a name and type and is typically constructed for a particular audience to convey an idea or to create a
        narrative description of part of the model. Diagrams can also be used to generate useful system artifacts such
        as XML schemas, database schemas, programming code and more. [<a
                href="https://sparxsystems.com/enterprise_architect_user_guide/15.1/model_domains/umldiagrams.html">ref</a>]
    </p>
    <hr/>
    <h3>Structural Models</h3>
    <h3>Class diagram</h3>
    <p>The Class diagram captures the logical structure of the system - the Classes - and things that make up the model.
        It is a static model, describing what exists and what attributes and behavior it has, rather than how something
        is done. On a Class diagram you can illustrate relationships between Classes and Interfaces using
        Generalizations, Aggregations and Associations, which are valuable in reflecting inheritance, composition or
        usage, and connections respectively.</p>
    <div><img src="data/cls-diagram.png" class="img-fluid" alt=""/></div>
    <h3>Composite Structure</h3>
    <p>A Composite Structure diagram reflects the internal collaboration of Classes, Interfaces or Components (and their
        properties) to describe a functionality. Composite Structure diagrams are similar to Class diagrams, but whilst
        Class diagrams model a static view of Class structures, including their attributes and behaviors, Composite
        Structure diagrams model a specific usage of the structure. You can use them to express run-time architectures,
        usage patterns and the participating elements' relationships, which might not be reflected by static
        diagrams.</p>
    <div><img src="data/cm-struct.png" class="img-fluid" alt=""/></div>
    <h3>Component</h3>
    <p>A Component diagram has a higher level of abstraction than a Class diagram; usually a component is implemented by
        one or more Classes (or Objects) at runtime. They are building blocks, built up so that eventually a component
        can encompass a large portion of a system.</p>
    <div><img src="data/cm.png" class="img-fluid" alt=""/></div>
    <h3>Deployment</h3>
    <p>A Deployment diagram shows how and where the system is to be deployed; that is, its execution architecture.</p>
    <div><img src="data/deploy.png" class="img-fluid" alt=""/></div>
    <hr/>
    <h2>Behavioral</h2>
    <h3>Use Case</h3>
    <p>Use Case diagrams capture Use Cases and the relationships between Actors and the subject (system).</p>
    <div><img src="data/usecase.png" class="img-fluid" alt=""/></div>
    <h3>StateMachines</h3>
    <p>StateMachines illustrate how an element (often a Class) can move between States, classifying its behavior
        according to transition triggers and constraining guards.</p>
    <div><img src="data/state.png" class="img-fluid" alt=""/></div>
    <h3>Sequence</h3>
    <p>A Sequence diagram is a structured representation of behavior as a series of sequential steps over time.</p>
    <div><img src="data/sequence.png" class="img-fluid" alt=""/></div>
    <h3>Communication</h3>
    <p>A Communication diagram is a diagram that shows the interactions between elements at run-time in much the same
        manner as a Sequence diagram. However, Communication diagrams are used to visualize inter-object relationships,
        while Sequence diagrams are more effective at visualizing processing over time.</p>
    <div><img src="data/communication.png" class="img-fluid" alt=""/></div>
    <hr/>
    <h2>Patterns</h2>
    <hr/>
    <h3>Creational patterns</h3>
    <ul>
        <li>Abstract factory</li>
        <li>Builder</li>
        <li>Dependency Injection</li>
        <li>Factory method</li>
        <li>Lazy initialization</li>
        <li>Multiton</li>
        <li>Object pool</li>
        <li>Prototype</li>
        <li>Singleton</li>
    </ul>
    <h4>Abstract factory</h4>
    <p>Provide an interface for creating families of related or dependent objects without specifying their concrete
        classes.</p>
    <div><img src="data/p-f.jpg" class="img-fluid" alt=""/></div>
    <hr/>
    <h4>Builder</h4>
    <p>Separate the construction of a complex object from its representation, allowing the same construction process to
        create various representations.</p>
    <div><img src="data/p-builder.png" class="img-fluid" alt=""/></div>
    <hr/>
    <h4>Dependency Injection</h4>
    <p>Separate the construction of a complex object from its representation, allowing the same construction process to
        create various representations.</p>
    <div><img src="data/p-di.jpg" class="img-fluid" alt=""/></div>
    <hr/>
    <h4>Factory method pattern</h4>
    <p>In class-based programming, the factory method pattern is a creational pattern that uses factory methods to deal
        with the problem of creating objects without having to specify the exact class of the object that will be
        created. This is done by creating objects by calling a factory method—either specified in an interface and
        implemented by child classes, or implemented in a base class and optionally overridden by derived classes—rather
        than by calling a constructor.</p>
    <div><img src="data/p-fm.jpg" class="img-fluid" alt=""/></div>
    <hr/>
    <h4>Lazy initialization</h4>
    <p>In computer programming, lazy initialization is the tactic of delaying the creation of an object, the calculation
        of a value, or some other expensive process until the first time it is needed. It is a kind of lazy evaluation
        that refers specifically to the instantiation of objects or other resources.</p>
    <hr/>
    <h4>Multiton pattern</h4>
    <p>In software engineering, the multiton pattern is a design pattern which generalizes the singleton pattern.
        Whereas the singleton allows only one instance of a class to be created, the multiton pattern allows for the
        controlled creation of multiple instances, which it manages through the use of a map.</p>
    <hr/>
    <h4>Object pool pattern</h4>
    <p>The object pool pattern is a software creational design pattern that uses a set of initialized objects kept ready
        to use – a "pool" – rather than allocating and destroying them on demand. A client of the pool will request an
        object from the pool and perform operations on the returned object. When the client has finished, it returns the
        object to the pool rather than destroying it; this can be done manually or automatically.</p>
    <hr/>
    <h4>Prototype</h4>
    <p>The prototype pattern is a creational design pattern in software development. It is used when the type of objects
        to create is determined by a prototypical instance, which is cloned to produce new objects.</p>
    <div><img src="data/f-proto.jpg" class="img-fluid" alt=""/></div>
    <hr/>
    <h4>Singleton</h4>
    <p>In software engineering, the singleton pattern is a software design pattern that restricts the instantiation of a
        class to one "single" instance. This is useful when exactly one object is needed to coordinate actions across
        the system. The term comes from the mathematical concept of a singleton.</p>
    <div><img src="data/p-singl.png" class="img-fluid" alt=""/></div>
    <hr/>
    <h3>Structural patterns</h3>
    <ul>
        <li>Adapter (Wrapper, Translator)</li>
        <li>Bridge</li>
        <li>Composite</li>
        <li>Decorator</li>
        <li>Facade</li>
        <li>Flyweight</li>
        <li>Front controller</li>
        <li>Marker</li>
        <li>Module</li>
        <li>Proxy</li>
        <li>Twin</li>
    </ul>
    <h4>Adapter</h4>
    <p>Converts one interface to another so that it matches what the client is expecting</p>
    <div><img src="data/p-adapter.jpg" class="img-fluid" alt=""/></div>
    <h4>Bridge</h4>
    <p>Decouple an abstraction from its implementation allowing the two to vary independently.</p>
    <div><img src="data/p-bridge.jpg" class="img-fluid" alt=""/></div>
    <h4>Composite</h4>
    <p>Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual
        objects and compositions of objects uniformly.</p>
    <div><img src="data/p-compose.jpg" class="img-fluid" alt=""/></div>
    <h4>Decorator</h4>
    <p>Dynamically adds responsibility to the interface by wrapping the original code. Attach additional
        responsibilities to an object dynamically keeping the same interface. Decorators provide a flexible alternative
        to subclassing for extending functionality. </p>
    <div><img src="data/p-decorator.jpg" class="img-fluid" alt=""/></div>
    <h4>Facade</h4>
    <p>Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that
        makes the subsystem easier to use.</p>
    <div><img src="data/p-facade.jpg" class="img-fluid" alt=""/></div>
    <h4>Flyweight</h4>
    <p>Use sharing to support large numbers of similar objects efficiently. A classic example usage of the flyweight
        pattern is the data structures for graphical representation of characters in a word processor. It might be
        desirable to have, for each character in a document, a glyph object containing its font outline, font metrics,
        and other formatting data, but this would amount to hundreds or thousands of bytes for each character. Instead,
        for every character there might be a reference to a flyweight glyph object shared by every instance of the same
        character in the document; only the position of each character (in the document and/or the page) would need to
        be stored internally.</p>
    <div><img src="data/f-flyweight.jpg" class="img-fluid" alt=""/></div>
    <h4>Front controller</h4>
    <p>The pattern relates to the design of Web applications. It provides a centralized entry point for handling
        requests.</p>
    <div><img src="data/p-fc.png" class="img-fluid" alt=""/></div>
    <h4>Marker</h4>
    <p>Empty interface to associate metadata with a class. An example of the application of marker interfaces from the
        Java programming language is the Serializable interface. </p>
    <h4>Module</h4>
    <p>Group several related elements, such as classes, singletons, methods, globally used, into a single conceptual
        entity. [<a href="https://www.oracle.com/corporate/features/understanding-java-9-modules.html">Java Modules</a>]
    </p>
    <h4>Proxy</h4>
    <p>Provide a surrogate or placeholder for another object to control access to it.</p>
    <div><img src="data/p-proxy.jpg" class="img-fluid" alt=""/></div>
    <h4>Twin</h4>
    <p>Twin allows modeling of multiple inheritance in programming languages that do not support this feature.</p>
    <div><img src="data/p-twin.png" class="img-fluid" alt=""/></div>

    <hr/>
    <h3>Behavioral patterns</h3>
    <ul>
        <li>Blackboard</li>
        <li>Chain of responsibility</li>
        <li>Command</li>
        <li>Interpreter</li>
        <li>Iterator</li>
        <li>Mediator</li>
        <li>Memento</li>
        <li>Null object</li>
        <li>Observer or Publish/subscribe</li>
        <li>Servant</li>
        <li>Specification</li>
        <li>State</li>
        <li>Strategy</li>
        <li>Template method</li>
        <li>Visitor</li>
    </ul>
    <h4>Blackboard</h4>
    <p>Artificial intelligence pattern for combining disparate sources of data (see blackboard system). That provides a
        computational framework for the design and implementation of systems that integrate large and diverse
        specialized modules, and implement complex, non-deterministic control strategies.</p>
    <div><img src="data/p-bb.png" class="img-fluid" alt=""/></div>
    <h4>Chain of responsibility</h4>
    <p>Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the
        request. Chain the receiving objects and pass the request along the chain until an object handles it.</p>
    <div><img src="data/f-cor.jpg" class="img-fluid" alt=""/></div>
    <h4>Command</h4>
    <p>Encapsulate a request as an object, thereby allowing for the parameterization of clients with different requests,
        and the queuing or logging of requests. It also allows for the support of undoable operations.</p>
    <div><img src="data/p-command.jpg" class="img-fluid" alt=""/></div>
    <h4>Interpreter</h4>
    <p>Given a language, define a representation for its grammar along with an interpreter that uses the representation
        to interpret sentences in the language. </p>
    <div><img src="data/p-inter.jpg" class="img-fluid" alt=""/></div>
    <h4>Iterator</h4>
    <p>Provide a way to access the elements of an aggregate object sequentially without exposing its underlying
        representation. </p>
    <div><img src="data/p-iter.jpg" class="img-fluid" alt=""/></div>
    <h4>Mediator</h4>
    <p>Define an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping
        objects from referring to each other explicitly, and it allows their interaction to vary independently.</p>
    <div><img src="data/m-mediator.jpg" class="img-fluid" alt=""/></div>
    <h4>Memento</h4>
    <p>Without violating encapsulation, capture and externalize an object's internal state allowing the object to be
        restored to this state later. The memento pattern is implemented with three objects: the originator, a caretaker
        and a memento. The originator is some object that has an internal state. The caretaker is going to do something
        to the originator, but wants to be able to undo the change. The caretaker first asks the originator for a
        memento object. Then it does whatever operation (or sequence of operations) it was going to do. To roll back to
        the state before the operations, it returns the memento object to the originator. The memento object itself is
        an opaque object (one which the caretaker cannot, or should not, change). When using this pattern, care should
        be taken if the originator may change other objects or resources - the memento pattern operates on a single
        object.</p>
    <div><img src="data/p-memento.jpg" class="img-fluid" alt=""/></div>
    <h4>Null object</h4>
    <p>Avoid null references by providing a default object. Null object is an object with no referenced value or with
        defined neutral ("null") behavior. </p>
    <h4>Observer</h4>
    <p>The subject, maintains a list of its dependents, called observers, and notifies them automatically of any state
        changes, usually by calling one of their methods. It is mainly used to implement distributed event handling
        systems, in "event driven" software. In those systems, the subject is usually called a "stream of events" or
        "stream source of events", while the observers are called "sink of events". The stream nomenclature simulates or
        adapts to a physical setup where the observers are physically separated and have no control over the emitted
        events of the subject/stream-source. This pattern then perfectly suits any process where data arrives through
        I/O, that is, where data is not available to the CPU at startup, but can arrive "randomly" (HTTP requests, GPIO
        data, user input from keyboard/mouse/..., distributed databases and blockchains, ...). Most modern languages
        have built-in "event" constructs which implement the observer pattern components. While not mandatory most
        'observers' implementations will use background threads listening for subject events and other support mechanism
        from the kernel (Linux epoll, ...)</p>
    <div><img src="data/p-obs.jpg" class="img-fluid" alt=""/></div>
    <h4>Publish/subscribe</h4>
    <p>Define a one-to-many dependency between objects where a state change in one object results in all its dependents
        being notified and updated automatically. Publish–subscribe is a messaging pattern where senders of messages,
        called publishers, do not program the messages to be sent directly to specific receivers, called subscribers,
        but instead categorize published messages into classes without knowledge of which subscribers, if any, there may
        be. Similarly, subscribers express interest in one or more classes and only receive messages that are of
        interest, without knowledge of which publishers, if any, there are.</p>
    <p>This pattern provides greater network scalability and a more dynamic network topology, with a resulting decreased
        flexibility to modify the publisher and the structure of the published data.</p>
    <h4>Servant</h4>
    <p>Define common functionality for a group of classes. The servant pattern is also frequently called helper class or
        utility class implementation for a given set of classes. The helper classes generally have no objects hence they
        have all static methods that act upon different kinds of class objects. A Servant is a class whose instance (or
        even just class) provides methods that take care of a desired service, while objects for which (or with whom)
        the servant does something, are taken as parameters.</p>
    <div><img src="data/p-servant.png" class="img-fluid" alt=""/></div>
    <h4>Specification</h4>
    <p>Recombinable business logic in a Boolean fashion. A specification pattern outlines a business rule that is
        combinable with other business rules. In this pattern, a unit of business logic inherits its functionality from
        the abstract aggregate Composite Specification class. The Composite Specification class has one function called
        IsSatisfiedBy that returns a boolean value. After instantiation, the specification is "chained" with other
        specifications, making new specifications easily maintainable, yet highly customizable business logic.
        Furthermore, upon instantiation the business logic may, through method invocation or inversion of control, have
        its state altered in order to become a delegate of other classes such as a persistence repository.</p>
    <div><img src="data/p-spec.png" class="img-fluid" alt=""/></div>
    <h4>State</h4>
    <p>Allow an object to alter its behavior when its internal state changes. The object will appear to change its
        class. The state pattern can be interpreted as a strategy pattern, which is able to switch a strategy through
        invocations of methods defined in the pattern's interface.</p>
    <div><img src="data/p-state.jpg" class="img-fluid" alt=""/></div>
    <h4>Strategy</h4>
    <p>Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm
        vary independently from clients that use it. Typically the strategy pattern stores a reference to some code in a
        data structure and retrieves it. This can be achieved by mechanisms such as the native function pointer, the
        first-class function, classes or class instances in object-oriented programming languages, or accessing the
        language implementation's internal storage of code via reflection.</p>
    <div><img src="data/p-strategy.jpg" class="img-fluid" alt=""/></div>
    <h4>Template method</h4>
    <p>Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template method lets
        subclasses redefine certain steps of an algorithm without changing the algorithm's structure. The helper methods
        may be either abstract methods, for which case subclasses are required to provide concrete implementations, or
        hook methods, which have empty bodies in the superclass. Subclasses can (but are not required to) customize the
        operation by overriding the hook methods. The intent of the template method is to define the overall structure
        of the operation, while allowing subclasses to refine, or redefine, certain steps.</p>
    <div><img src="data/p-template.jpg" class="img-fluid" alt=""/></div>
    <h4>Visitor</h4>
    <p>Represent an operation to be performed on the elements of an object structure. Visitor lets a new operation be
        defined without changing the classes of the elements on which it operates. In essence, the visitor allows adding
        new virtual functions to a family of classes, without modifying the classes. Instead, a visitor class is created
        that implements all of the appropriate specializations of the virtual function. The visitor takes the instance
        reference as input, and implements the goal through double dispatch.</p>
    <div><img src="data/p-visitor.jpg" class="img-fluid" alt=""/></div>
    <hr/>
    <h3>Functional</h3>
    <ul>
        <li>HOF (Higher-order function)</li>
        <li>Closure</li>
        <li>Generator</li>
    </ul>
    <h4>HOF (Higher-order function)</h4>
    <pre><code class="java">Function&lt;IntUnaryOperator, IntUnaryOperator&gt; twice = f -&gt; f.andThen(f);
twice.apply(x -&gt; x + 3).applyAsInt(7); // 13</code></pre>
    <h4>Closure</h4>
    <p>Closures are useful because they let you associate data (the lexical environment) with a function that operates
        on that data. This has obvious parallels to object-oriented programming, where objects allow you to associate
        data (the object's properties) with one or more methods.</p>
    <pre><code class="js">function makeSizer(size) {
  return function() {
    document.body.style.fontSize = size + 'px';
  };
}

var size12 = makeSizer(12);
var size14 = makeSizer(14);
var size16 = makeSizer(16);</code></pre>
    <h4>Generator</h4>
    <p>A generator is very similar to a function that returns an array, in that a generator has parameters, can be
        called, and generates a sequence of values. However, instead of building an array containing all the values and
        returning them all at once, a generator yields the values one at a time, which requires less memory and allows
        the caller to get started processing the first few values immediately. In short, a generator looks like a
        function but behaves like an iterator.</p>
    <pre><code class="java">public Iterable&lt;Integer&gt; fibonacci(int limit){
    return IntStream.generate(new IntSupplier() {
        int a = 1, b = 2;

        public int getAsInt() {
            int temp = a;
            a = b;
            b = a + temp;
            return temp;
        }
    }).limit(limit).boxed()::iterator;
}

// this could then be used as...
for (int f: fibonacci(10)) {
    System.out.println(f);
}</code></pre>
    <hr/>
    <h3>Concurrency patterns</h3>
    <p>https://en.wikipedia.org/wiki/Pattern-Oriented_Software_Architecture</p>
    <p>https://docs.oracle.com/javase/tutorial/essential/concurrency/index.html</p>
    <ul>
        <li>Active Object</li>
        <li>Balking</li>
        <li>Actor</li>
        <li>Barrier</li>
        <li>Coroutine</li>
        <li>Binding properties</li>
        <li>Fiber</li>
        <li>Futex</li>
        <li>Futures and promises</li>
        <li>Compute kernel</li>
        <li>Double-checked locking</li>
        <li>Event-based asynchronous</li>
        <li>Guarded suspension</li>
        <li>Join</li>
        <li>Lock</li>
        <li>Messaging design pattern (MDP)</li>
        <li>Monitor object</li>
        <li>Reactor</li>
        <li>Read-write lock</li>
        <li>Scheduler</li>
        <li>Thread pool</li>
        <li>Thread-specific storage</li>
        <li>Immutable object</li>
        <li>Nuclear</li>
        <li>Proactor</li>
        <li>STM (Software transactional memory)</li>
    </ul>
    <h4>Active Object</h4>
    <p>Decouples method execution from method invocation that reside in their own thread of control. The goal is to
        introduce concurrency, by using asynchronous method invocation and a scheduler for handling requests.</p>
    <div>
        The pattern consists of six elements:

        <ul>
            <li>A proxy, which provides an interface towards clients with publicly accessible methods.</li>
            <li>An interface which defines the method request on an active object.</li>
            <li>A list of pending requests from clients.</li>
            <li>A scheduler, which decides which request to execute next.</li>
            <li>The implementation of the active object method.</li>
            <li>A callback or variable for the client to receive the result.</li>
        </ul>
    </div>
    <h4>Balking</h4>
    <p>Only execute an action on an object when the object is in a particular state. For example, if an object reads ZIP
        files and a calling method invokes a get method on the object when the ZIP file is not open, the object would
        "balk" at the request. In the Java programming language, for example, an IllegalStateException might be thrown
        under these circumstances.</p>
    <pre><code class="java">public class Example {
    private boolean jobInProgress = false;

    public void job() {
        synchronized(this) {
            if (jobInProgress) {
                return;
            }
            jobInProgress = true;
        }
        // Code to execute job goes here
        // ...
        jobCompleted();
    }

    void jobCompleted() {
        synchronized(this) {
            jobInProgress = false;
        }
    }
}</code></pre>
    <h4>Actor</h4>
    <p>The actor model adopts the philosophy that everything is an actor. This is similar to the everything is an object
        philosophy used by some object-oriented programming languages. An actor is a computational entity that, in
        response to a message it receives, can concurrently:</p>
    <ul>
        <li>send a finite number of messages to other actors;</li>
        <li>create a finite number of new actors;</li>
        <li>designate the behavior to be used for the next message it receives.</li>
        <li>There is no assumed sequence to the above actions and they could be carried out in parallel.</li>
    </ul>
    <h4>Binding properties</h4>
    <p>Combining multiple observers to force properties in different objects to be synchronized or coordinated in some
        way. As an alternative to the aspect-oriented implementation of mutual properties, property binding can be
        proposed.</p>
    <pre><code>bind_multiple_one_way(src_obj, src_prop, dst_objs[], dst_props[])
{
  for (i, j) in (dst_objs, dst_props)
  {
    bind_properties_one_way(src_obj, src_prop, i, j);
  }
}

// In this pseudo-code are not taken into the account initial values assignments
bind_two_way(prop1, prop2)
{
  bind(prop1, prop2);
  bind(prop2, prop1);
}


on_property_change(src_prop, dst_prop)
{
  block_signal(src_obj, on_property_change);
  dst_prop := src_prop;
  unblock_signal(src_obj, on_property_change);
}</code></pre>

    <h4>Compute kernel</h4>
    <p>In computing, a compute kernel is a routine compiled for high throughput accelerators (such as graphics
        processing units (GPUs), digital signal processors (DSPs) or field-programmable gate arrays (FPGAs)), separate
        from but used by a main program (typically running on a central processing unit). They are sometimes called
        compute shaders, sharing execution units with vertex shaders and pixel shaders on GPUs, but are not limited to
        execution on one class of device, or graphics APIs. Compute kernels roughly correspond to inner loops when
        implementing algorithms in traditional languages (except there is no implied sequential operation), or to code
        passed to internal iterators.</p>

    <h4>Double-checked locking</h4>
    <p>Reduce the overhead of acquiring a lock by first testing the locking criterion (the 'lock hint') in an unsafe
        manner; only if that succeeds does the actual locking logic proceed. Can be unsafe when implemented in some
        language/hardware combinations. It can therefore sometimes be considered an anti-pattern.</p>
    <pre><code class="java">// Single-threaded version
class Foo {
    private Helper helper;
    public Helper getHelper() {
        if (helper == null) {
            helper = new Helper();
        }
        return helper;
    }

    // other functions and members...
}

class Foo {
    private volatile Helper helper;
    public Helper getHelper() {
        Helper localRef = helper;
        if (localRef == null) {
            synchronized (this) {
                localRef = helper;
                if (localRef == null) {
                    helper = localRef = new Helper();
                }
            }
        }
        return localRef;
    }

    // other functions and members...
}</code></pre>
    <h4>Event-based asynchronous</h4>
    <p>Addresses problems with the asynchronous pattern that occur in multithreaded programs. Asynchronous pattern is a
        design pattern in which the call site is not blocked while waiting for the called code to finish. Instead, the
        calling thread is notified when the reply arrives. Polling for a reply is an undesired option. FutureTask class
        in Java use events to solve the same problem. This pattern is a variant of AMI whose implementation carries more
        overhead, but it is useful for objects representing software components.</p>
    <h4>Guarded suspension</h4>
    <p>Manages operations that require both a lock to be acquired and a precondition to be satisfied before the
        operation can be executed. The guarded suspension pattern is typically applied to method calls in
        object-oriented programs, and involves suspending the method call, and the calling thread, until the
        precondition (acting as a guard) is satisfied. Because it is blocking, the guarded suspension pattern is
        generally only used when the developer knows that a method call will be suspended for a finite and reasonable
        period of time. If a method call is suspended for too long, then the overall program will slow down or stop,
        waiting for the precondition to be satisfied. If the developer knows that the method call suspension will be
        indefinite or for an unacceptably long period, then the balking pattern may be preferred.</p>
    <pre><code>public class Example {
    synchronized void guardedMethod() {
        while (!preCondition()) {
            try {
                // Continue to wait
                wait();
                // …
            } catch (InterruptedException e) {
                // …
            }
        }
        // Actual task implementation
    }
    synchronized void alterObjectStateMethod() {
        // Change the object state
        // …
        // Inform waiting threads
        notify();
    }
}</code></pre>
    <h4>Join</h4>
    <p>Join-pattern provides a way to write concurrent, parallel and distributed programs by message passing. Compared
        to the use of threads and locks, this is a high-level programming model. This template is based on join-calculus
        and uses pattern matching. Concretely, this is done by allowing the join definition of several functions and/or
        channels by matching concurrent call and messages patterns. It is a type of concurrency pattern because it makes
        easier and more flexible for these entities to communicate and deal with the multi-threaded programming
        paradigm. [<a href="https://en.wikipedia.org/wiki/Join-pattern">ref</a>]</p>
    <p>Join-pattern in classic programming literature:</p>
    <ul>
        <li>Barriers</li>
        <li>Dining philosophers problem</li>
        <li>Mutual exclusion</li>
        <li>Reader-writer locking</li>
        <li>Semaphores</li>
    </ul>
    <h4>Lock</h4>
    <p>One thread puts a "lock" on a resource, preventing other threads from accessing or modifying it. Java provides
        the keyword synchronized to lock code blocks, methods or objects and libraries featuring concurrency-safe data
        structures.</p>
    <h4>Messaging design pattern (MDP)</h4>
    <p>Allows the interchange of information (i.e. messages) between components and applications. In telecommunications,
        a message exchange pattern (MEP) describes the pattern of messages required by a communications protocol to
        establish or use a communication channel. There are two major message exchange patterns — a request–response
        pattern, and a one-way pattern. For example, HTTP is a request–response pattern protocol, and UDP is a one-way
        pattern.</p>
    <h4>Monitor object</h4>
    <p>An object whose methods are subject to mutual exclusion, thus preventing multiple objects from erroneously trying
        to use it at the same time. Monitor is a synchronization construct that allows threads to have both mutual
        exclusion and the ability to wait (block) for a certain condition to become false. Monitors also have a
        mechanism for signaling other threads that their condition has been met. A monitor consists of a mutex (lock)
        object and condition variables. A condition variable essentially is a container of threads that are waiting for
        a certain condition. Monitors provide a mechanism for threads to temporarily give up exclusive access in order
        to wait for some condition to be met, before regaining exclusive access and resuming their task.</p>
    <pre><code>public void addName(String name) {
    synchronized(this) {
        lastName = name;
        nameCount++;
    }
    nameList.add(name);
}</code></pre>
    <h4>Reactor</h4>
    <p>A reactor object provides an asynchronous interface to resources that must be handled synchronously. The service
        handler then demultiplexes the incoming requests and dispatches them synchronously to the associated request
        handlers. </p>
    <h4>Read-write lock</h4>
    <p>Allows concurrent read access to an object, but requires exclusive access for write operations.An RW lock allows
        concurrent access for read-only operations, while write operations require exclusive access. This means that
        multiple threads can read the data in parallel but an exclusive lock is needed for writing or modifying data.
        When a writer is writing the data, all other writers or readers will be blocked until the writer is finished
        writing. A common use might be to control access to a data structure in memory that cannot be updated atomically
        and is invalid (and should not be read by another thread) until the update is complete.</p>
    <pre><code class="java">class CachedData {
   Object data;
   volatile boolean cacheValid;
   final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();

   void processCachedData() {
     rwl.readLock().lock();
     if (!cacheValid) {
        // Must release read lock before acquiring write lock
        rwl.readLock().unlock();
        rwl.writeLock().lock();
        try {
          // Recheck state because another thread might have
          // acquired write lock and changed state before we did.
          if (!cacheValid) {
            data = ...
            cacheValid = true;
          }
          // Downgrade by acquiring read lock before releasing write lock
          rwl.readLock().lock();
        } finally {
          rwl.writeLock().unlock(); // Unlock write, still hold read
        }
     }

     try {
       use(data);
     } finally {
       rwl.readLock().unlock();
     }
   }
 }</code></pre>
    <h4>Stamped Lock</h4>
    <p>A capability-based lock with three modes for controlling read/write access. The state of a StampedLock consists
        of a version and mode. Lock acquisition methods return a stamp that represents and controls access with respect
        to a lock state; "try" versions of these methods may instead return the special value zero to represent failure
        to acquire access. Lock release and conversion methods require stamps as arguments, and fail if they do not
        match the state of the lock. The three modes are:</p>
    <ul>
        <li>Writing. Method writeLock() possibly blocks waiting for exclusive access, returning a stamp that can be used
            in method unlockWrite(long) to release the lock. Untimed and timed versions of tryWriteLock are also
            provided. When the lock is held in write mode, no read locks may be obtained, and all optimistic read
            validations will fail.
        </li>
        <li>Reading. Method readLock() possibly blocks waiting for non-exclusive access, returning a stamp that can be
            used in method unlockRead(long) to release the lock. Untimed and timed versions of tryReadLock are also
            provided.
        </li>
        <li>Optimistic Reading. Method tryOptimisticRead() returns a non-zero stamp only if the lock is not currently
            held in write mode. Method validate(long) returns true if the lock has not been acquired in write mode since
            obtaining a given stamp. This mode can be thought of as an extremely weak version of a read-lock, that can
            be broken by a writer at any time. The use of optimistic mode for short read-only code segments often
            reduces contention and improves throughput. However, its use is inherently fragile. Optimistic read sections
            should only read fields and hold them in local variables for later use after validation. Fields read while
            in optimistic mode may be wildly inconsistent, so usage applies only when you are familiar enough with data
            representations to check consistency and/or repeatedly invoke method validate(). For example, such steps are
            typically required when first reading an object or array reference, and then accessing one of its fields,
            elements or methods.
        </li>
    </ul>
    <p>StampedLocks are designed for use as internal utilities in the development of thread-safe components. Their use
        relies on knowledge of the internal properties of the data, objects, and methods they are protecting. They are
        not reentrant, so locked bodies should not call other unknown methods that may try to re-acquire locks (although
        you may pass a stamp to other methods that can use or convert it). The use of read lock modes relies on the
        associated code sections being side-effect-free. Unvalidated optimistic read sections cannot call methods that
        are not known to tolerate potential inconsistencies. Stamps use finite representations, and are not
        cryptographically secure (i.e., a valid stamp may be guessable). Stamp values may recycle after (no sooner than)
        one year of continuous operation. A stamp held without use or validation for longer than this period may fail to
        validate correctly. StampedLocks are serializable, but always deserialize into initial unlocked state, so they
        are not useful for remote locking.</p>
    <pre><code class="java"> class Point {
   private double x, y;
   private final StampedLock sl = new StampedLock();

   void move(double deltaX, double deltaY) { // an exclusively locked method
     long stamp = sl.writeLock();
     try {
       x += deltaX;
       y += deltaY;
     } finally {
       sl.unlockWrite(stamp);
     }
   }

   double distanceFromOrigin() { // A read-only method
     long stamp = sl.tryOptimisticRead();
     double currentX = x, currentY = y;
     if (!sl.validate(stamp)) {
        stamp = sl.readLock();
        try {
          currentX = x;
          currentY = y;
        } finally {
           sl.unlockRead(stamp);
        }
     }
     return Math.sqrt(currentX * currentX + currentY * currentY);
   }

   void moveIfAtOrigin(double newX, double newY) { // upgrade
     // Could instead start with optimistic, not read mode
     long stamp = sl.readLock();
     try {
       while (x == 0.0 && y == 0.0) {
         long ws = sl.tryConvertToWriteLock(stamp);
         if (ws != 0L) {
           stamp = ws;
           x = newX;
           y = newY;
           break;
         }
         else {
           sl.unlockRead(stamp);
           stamp = sl.writeLock();
         }
       }
     } finally {
       sl.unlock(stamp);
     }
   }
 }</code></pre>
    <h4>Scheduler</h4>
    <p>Explicitly control when threads may execute single-threaded code. A scheduler is what carries out the scheduling
        activity. Schedulers are often implemented so they keep all computer resources busy (as in load balancing),
        allow multiple users to share system resources effectively, or to achieve a target quality of service.
        Scheduling is fundamental to computation itself, and an intrinsic part of the execution model of a computer
        system; the concept of scheduling makes it possible to have computer multitasking with a single central
        processing unit (CPU).</p>
    <h4>Thread pool</h4>
    <p>A number of threads are created to perform a number of tasks, which are usually organized in a queue. Typically,
        there are many more tasks than threads. Can be considered a special case of the object pool pattern.Often also
        called a replicated workers or worker-crew model, a thread pool maintains multiple threads waiting for tasks to
        be allocated for concurrent execution by the supervising program. By maintaining a pool of threads, the model
        increases performance and avoids latency in execution due to frequent creation and destruction of threads for
        short-lived tasks. The number of available threads is tuned to the computing resources available to the program,
        such as a parallel task queue after completion of execution.</p>
    <h4>Thread-specific storage</h4>
    <p>Static or "global" memory local to a thread. While the use of global variables is generally discouraged in modern
        programming, legacy operating systems such as UNIX are designed for uniprocessor hardware and require some
        additional mechanism to retain the semantics of pre-reentrant APIs. An example of such situations is where
        functions use a global variable to set an error condition (for example the global variable errno used by many
        functions of the C library). If errno were a global variable, a call of a system function on one thread may
        overwrite the value previously set by a call of a system function on a different thread, possibly before
        following code on that different thread could check for the error condition. The solution is to have errno be a
        variable that looks like it is global, but in fact exists once per thread—i.e., it lives in thread-local
        storage. A second use case would be multiple threads accumulating information into a global variable. To avoid a
        race condition, every access to this global variable would have to be protected by a mutex. Alternatively, each
        thread might accumulate into a thread-local variable (that, by definition, cannot be read from or written to
        from other threads, implying that there can be no race conditions). Threads then only have to synchronise a
        final accumulation from their own thread-local variable into a single, truly global variable.</p>
    <pre><code class="java">private static final ThreadLocal&lt;Integer&gt; myThreadLocalInteger = new ThreadLocal&lt;&gt;();</code></pre>
    <h4>Immutable object</h4>
    <p>Strings and other concrete objects are typically expressed as immutable objects to improve readability and
        runtime efficiency in object-oriented programming. Immutable objects are also useful because they are inherently
        thread-safe. This is in contrast to a mutable object (changeable object), which can be modified after it is
        created. In some cases, an object is considered immutable even if some internally used attributes change, but
        the object's state appears unchanging from an external point of view. For example, an object that uses
        memoization to cache the results of expensive computations could still be considered an immutable object. Other
        benefits are that they are simpler to understand and reason about and offer higher security than mutable
        objects. A classic example of an immutable object is an instance of the Java String class.</p>
    <h4>Proactor</h4>
    <p>Proactor is a software design pattern for event handling in which long running activities are running in an
        asynchronous part. A completion handler is called after the asynchronous part has terminated. The proactor
        pattern can be considered to be an asynchronous variant of the synchronous reactor pattern.</p>
    <div><img src="data/p-proactor.png" class="img-fluid" alt=""/></div>
    <h4>STM (Software transactional memory)</h4>
    <p>In computer science, software transactional memory (STM) is a concurrency control mechanism analogous to database
        transactions for controlling access to shared memory in concurrent computing. It is an alternative to lock-based
        synchronization. STM is a strategy implemented in software, rather than as a hardware component. A transaction
        in this context occurs when a piece of code executes a series of reads and writes to shared memory. </p>
    <h4>Barrier</h4>
    <p>In parallel computing, a barrier is a type of synchronization method. A barrier for a group of threads or
        processes in the source code means any thread/process must stop at this point and cannot proceed until all other
        threads/processes reach this barrier.</p>
    <h4>Coroutine</h4>
    <p>Coroutines are computer program components that generalize subroutines for non-preemptive multitasking, by
        allowing execution to be suspended and resumed. Coroutines are well-suited for implementing familiar program
        components such as cooperative tasks, exceptions, event loops, iterators, infinite lists and pipes.</p>
    <p>Kotlin example:</p>
    <pre><code class="kotlin">suspend fun main() = coroutineScope {
    launch {
       delay(1000)
       println("Kotlin Coroutines World!")
    }
    println("Hello")
}</code></pre>
    <h4>Futures and promises</h4>
    <p>In computer science, future, promise, delay, and deferred refer to constructs used for synchronizing program
        execution in some concurrent programming languages. They describe an object that acts as a proxy for a result
        that is initially unknown, usually because the computation of its value is not yet complete.</p>
    <p>Java example:</p>
    <pre><code class="java">public class SquareCalculator {

    private ExecutorService executor
      = Executors.newSingleThreadExecutor();

    public Future&lt;Integer&gt; calculate(Integer input) {
        return executor.submit(() -> {
            Thread.sleep(1000);
            return input * input;
        });
    }
}</code></pre>

    <hr/>
    <h3>Architectural</h3>
    <ul>
        <li>Layers</li>
        <li>Pipes & filters</li>
        <li>Broker</li>
        <li>MVC</li>
        <li>Presentation-Abstraction-Control</li>
    </ul>
    <h4>Layers</h4>
    <p>In object-oriented design, a layer is a group of classes that have the same set of link-time module dependencies
        to other modules.In other words, a layer is a group of reusable components that are reusable in similar
        circumstances. In programming languages, the layer distinction is often expressed as "import" dependencies
        between software modules. The most common architecture pattern is the layered architecture pattern, otherwise
        known as the n-tier architecture pattern. This pattern is the de facto standard for most Java EE applications
        and therefore is widely known by most architects, designers, and developers. The layered architecture pattern
        closely matches the traditional IT communication and organizational structures found in most companies, making
        it a natural choice for most business application development efforts. [<a
                href="https://www.oreilly.com/library/view/software-architecture-patterns/9781491971437/ch01.html">ref</a>]
    </p>
    <div><img src="data/layers.png" class="img-fluid" alt=""/></div>
    <h4>Event-Driven Architecture</h4>
    <p>The event-driven architecture pattern is a popular distributed asynchronous architecture pattern used to produce
        highly scalable applications. It is also highly adaptable and can be used for small applications and as well as
        large, complex ones. The event-driven architecture is made up of highly decoupled, single-purpose event
        processing components that asynchronously receive and process events.</p>
    <div><img src="data/events.png" class="img-fluid" alt=""/></div>
    <h4>Microkernel Architecture</h4>
    <p>The microkernel architecture pattern (sometimes referred to as the plug-in architecture pattern) is a natural
        pattern for implementing product-based applications. A product-based application is one that is packaged and
        made available for download in versions as a typical third-party product. However, many companies also develop
        and release their internal business applications like software products, complete with versions, release notes,
        and pluggable features. These are also a natural fit for this pattern. The microkernel architecture pattern
        allows you to add additional application features as plug-ins to the core application, providing extensibility
        as well as feature separation and isolation.</p>
    <div><img src="data/mk.png" class="img-fluid" alt=""/></div>

    <hr/>
    <h3>Distributed patterns</h3>
    <p>[<a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/">MSDN Cloud Design Patterns</a>]</p>
    <ul>
        <li>Ambassador</li>
        <li>Anti-Corruption Layer</li>
        <li>Asynchronous Request-Reply</li>
        <li>Backends for Frontends</li>
        <li>Bulkhead</li>
        <li>Cache-Aside</li>
        <li>Choreography</li>
        <li>Circuit Breaker</li>
        <li>Claim Check</li>
        <li>Compensating Transaction</li>
        <li>Competing Consumers</li>
        <li>Compute Resource Consolidation</li>
        <li>CQRS</li>
        <li>Event Sourcing</li>
        <li>External Configuration Store</li>
        <li>Federated Identity</li>
        <li>Gatekeeper</li>
        <li>Gateway Aggregation</li>
        <li>Gateway Offloading</li>
        <li>Health endpoint</li>
        <li>Index Table</li>
        <li>Leader Election</li>
        <li>MapReduce</li>
        <li>Materialized View</li>
        <li>Pipes & Filters</li>
        <li>Priority Queue</li>
        <li>Publisher-Subscriber</li>
        <li>Queue-Based Load Leveling</li>
        <li>Retry</li>
        <li>Scheduler Agent Supervisor</li>
        <li>Sequential Convoy</li>
        <li>Sharding</li>
        <li>Sidecar</li>
        <li>Static Content Hosting</li>
        <li>Strangler</li>
        <li>Throttling</li>
        <li>Valet Key</li>
    </ul>
    <h4>Ambassador</h4>
    <p>An Ambassador container is a sidecar container that is in charge of proxying connections from the application
        container to other services. However, while the Adapter container acts as a reverse proxy, the Ambassador
        container acts as a client proxy. You might be wondering, why do we need to proxy the application connection
        requests? Because we need to follow the separation of concerns principle. Each container should do it’s task and
        do it well. If there are other tasks that requires the application’s function in order to work correctly, we may
        hand those tasks to the sidecar container. [<a
                href="https://www.magalix.com/blog/kubernetes-patterns-the-ambassador-pattern">ref</a>]</p>
    <p>Well-known use case for the Ambassador container is when your application needs to connect to a caching server
        like Memcached or Redis. Let’s have a Redis example scenario to demonstrate this pattern.</p>
    <div><img src="data/ambressor.png" class="img-fluid" alt=""/></div>
    <h4>Anti-Corruption Layer</h4>
    <p>Implement a facade or adapter layer between different subsystems that don't share the same semantics. This layer
        translates requests that one subsystem makes to the other subsystem. Use this pattern to ensure that an
        application's design is not limited by dependencies on outside subsystems. This pattern was first described by
        Eric Evans in Domain-Driven Design.</p>
    <p>Most applications rely on other systems for some data or functionality. For example, when a legacy application is
        migrated to a modern system, it may still need existing legacy resources. New features must be able to call the
        legacy system. This is especially true of gradual migrations, where different features of a larger application
        are moved to a modern system over time.</p>
    <p>The diagram above shows an application with two subsystems. Subsystem A calls to subsystem B through an
        anti-corruption layer. Communication between subsystem A and the anti-corruption layer always uses the data
        model and architecture of subsystem A. Calls from the anti-corruption layer to subsystem B conform to that
        subsystem's data model or methods. The anti-corruption layer contains all of the logic necessary to translate
        between the two systems. The layer can be implemented as a component within the application or as an independent
        service.</p>
    <b>When to use this pattern</b>. Use this pattern when:
    <ul>
        <li>A migration is planned to happen over multiple stages, but integration between new and legacy systems needs
            to
            be maintained.
        </li>
        <li>Two or more subsystems have different semantics, but still need to communicate.</li>
        <li>This pattern may not be suitable if there are no significant semantic differences between new and legacy
            systems.
        </li>
    </ul>
    <div><img src="data/anti-corruption-layer.png" class="img-fluid" alt=""/></div>
    <h4>Asynchronous Request-Reply</h4>
    <p>Decouple backend processing from a frontend host, where backend processing needs to be asynchronous, but the
        frontend still needs a clear response. In modern application development, it's normal for client applications —
        often code running in a web-client (browser) — to depend on remote APIs to provide business logic and compose
        functionality. These APIs may be directly related to the application or may be shared services provided by a
        third party. Commonly these API calls take place over the HTTP(S) protocol and follow REST semantics.</p>
    <div><img src="data/async-request-fn.png" class="img-fluid" alt=""/></div>
    <h4>Backends for Frontends</h4>
    <p>Create separate backend services to be consumed by specific frontend applications or interfaces. This pattern is
        useful when you want to avoid customizing a single backend for multiple interfaces.</p>
    <div><img src="data/backend-for-frontend-example.png" class="img-fluid" alt=""/></div>
    <h4>Bulkhead</h4>
    <p>Isolate elements of an application into pools so that if one fails, the others will continue to function. The
        Bulkhead pattern is a type of application design that is tolerant of failure. In a bulkhead architecture,
        elements of an application are isolated into pools so that if one fails, the others will continue to function.
        It's named after the sectioned partitions (bulkheads) of a ship's hull. If the hull of a ship is compromised,
        only the damaged section fills with water, which prevents the ship from sinking.</p>
    <div><img src="data/bulkhead-1.png" class="img-fluid" alt=""/></div>
    <div><img src="data/bulkhead-2.png" class="img-fluid" alt=""/></div>
    <h4>Cache-Aside</h4>
    <p>Load data on demand into a cache from a data store. Load data on demand into a cache from a data store. This can
        improve performance and also helps to maintain consistency between data held in the cache and data in the
        underlying data store. Applications use a cache to improve repeated access to information held in a data store.
        However, it's impractical to expect that cached data will always be completely consistent with the data in the
        data store. Applications should implement a strategy that helps to ensure that the data in the cache is as
        up-to-date as possible, but can also detect and handle situations that arise when the data in the cache has
        become stale.</p>
    <div><img src="data/cache-aside-diagram.png" class="img-fluid" alt=""/></div>
    <h4>Choreography</h4>
    <p>Let each service decide when and how a business operation is processed, instead of depending on a central
        orchestrator. Have each component of the system participate in the decision-making process about the workflow of
        a business transaction, instead of relying on a central point of control. Use the choreography pattern if you
        expect to update, remove, or add new services frequently. The entire app can be modified with lesser effort and
        minimal disruption to existing services.</p>
    <div><img src="data/choreography-pattern.png" class="img-fluid" alt=""/></div>
    <h4>Circuit Breaker</h4>
    <p>Handle faults that might take a variable amount of time to fix when connecting to a remote service or
        resource. Handle faults that might take a variable amount of time to recover from, when connecting to a remote
        service or resource. This can improve the stability and resiliency of an application.</p>
    <p>In a distributed environment, calls to remote resources and services can fail due to transient faults, such as
        slow network connections, timeouts, or the resources being overcommitted or temporarily unavailable. These
        faults typically correct themselves after a short period of time, and a robust cloud application should be
        prepared to handle them by using a strategy such as the Retry pattern.
    </p>
    <p>However, there can also be situations where faults are due to unanticipated events, and that might take much
        longer to fix. These faults can range in severity from a partial loss of connectivity to the complete failure of
        a service. In these situations it might be pointless for an application to continually retry an operation that
        is unlikely to succeed, and instead the application should quickly accept that the operation has failed and
        handle this failure accordingly.</p>
    <div><img src="data/MRA-resizer-health-check.png" class="img-fluid" alt=""/></div>
    <h4>Claim Check</h4>
    <p>Split a large message into a claim check and a payload to avoid overwhelming a message bus. Split a large message
        into a claim check and a payload. Send the claim check to the messaging platform and store the payload to an
        external service. This pattern allows large messages to be processed, while protecting the message bus and the
        client from being overwhelmed or slowed down. This pattern also helps to reduce costs, as storage is usually
        cheaper than resource units used by the messaging platform.</p>
    <p>A messaging-based architecture at some point must be able to send, receive, and manipulate large messages. Such
        messages may contain anything, including images (for example, MRI scans), sound files (for example, call-center
        calls), text documents, or any kind of binary data of arbitrary size.</p>
    <div><img src="data/claim-check.jpg" class="img-fluid" alt=""/></div>
    <h4>Compensating Transaction</h4>
    <p>Undo the work performed by a series of steps, which together define an eventually consistent operation. Undo the
        work performed by a series of steps, which together define an eventually consistent operation, if one or more of
        the steps fail. Operations that follow the eventual consistency model are commonly found in cloud-hosted
        applications that implement complex business processes and workflows.
    </p>
    <p>Applications running in the cloud frequently modify data. This data might be spread across various data sources
        held in different geographic locations. To avoid contention and improve performance in a distributed
        environment, an application shouldn't try to provide strong transactional consistency. Rather, the application
        should implement eventual consistency. In this model, a typical business operation consists of a series of
        separate steps. While these steps are being performed, the overall view of the system state might be
        inconsistent, but when the operation has completed and all of the steps have been executed the system should
        become consistent again.</p>
    <p>A challenge in the eventual consistency model is how to handle a step that has failed. In this case it might be
        necessary to undo all of the work completed by the previous steps in the operation. However, the data can't
        simply be rolled back because other concurrent instances of the application might have changed it. Even in cases
        where the data hasn't been changed by a concurrent instance, undoing a step might not simply be a matter of
        restoring the original state. It might be necessary to apply various business-specific rules (see the travel
        website described in the Example section).</p>
    <p>If an operation that implements eventual consistency spans several heterogeneous data stores, undoing the steps
        in the operation will require visiting each data store in turn. The work performed in every data store must be
        undone reliably to prevent the system from remaining inconsistent.</p>
    <div><img src="data/compensating-transaction-diagram.png" class="img-fluid" alt=""/></div>
    <h4>Competing Consumers</h4>
    <p>Enable multiple concurrent consumers to process messages received on the same messaging channel. Enable multiple
        concurrent consumers to process messages received on the same messaging channel. This enables a system to
        process multiple messages concurrently to optimize throughput, to improve scalability and availability, and to
        balance the workload.</p>
    <p>An application running in the cloud is expected to handle a large number of requests. Rather than process each
        request synchronously, a common technique is for the application to pass them through a messaging system to
        another service (a consumer service) that handles them asynchronously. This strategy helps to ensure that the
        business logic in the application isn't blocked while the requests are being processed.</p>
    <div><img src="data/competing-consumers-diagram.png" class="img-fluid" alt=""/></div>
    <h4>Compute Resource Consolidation</h4>
    <p>Consolidate multiple tasks or operations into a single computational unit. This can increase compute resource
        utilization, and reduce the costs and management overhead associated with performing compute processing in
        cloud-hosted applications.</p>
    <p>A cloud application often implements a variety of operations. In some solutions it makes sense to follow the
        design principle of separation of concerns initially, and divide these operations into separate computational
        units that are hosted and deployed individually (for example, as separate App Service web apps, separate Virtual
        Machines, or separate Cloud Service roles). However, although this strategy can help simplify the logical design
        of the solution, deploying a large number of computational units as part of the same application can increase
        runtime hosting costs and make management of the system more complex.</p>
    <p>As an example, the figure shows the simplified structure of a cloud-hosted solution that is implemented using
        more than one computational unit. Each computational unit runs in its own virtual environment. Each function has
        been implemented as a separate task (labeled Task A through Task E) running in its own computational unit.</p>
    <div><img src="data/compute-resource-consolidation-diagram.png" class="img-fluid" alt=""/></div>
    <div><img src="data/compute-resource-consolidation-lifecycle.png" class="img-fluid" alt=""/></div>
    <h4>CQRS</h4>
    <p>Segregate operations that read data from operations that update data by using separate interfaces. The Command
        and Query Responsibility Segregation (CQRS) pattern separates read and update operations for a data store.
        Implementing CQRS in your application can maximize its performance, scalability, and security. The flexibility
        created by migrating to CQRS allows a system to better evolve over time and prevents update commands from
        causing merge conflicts at the domain level.
    </p>
    <div><img src="data/command-and-query-responsibility-segregation-cqrs-tradition-crud.png" class="img-fluid" alt=""/>
    </div>
    <div><img src="data/command-and-query-responsibility-segregation-cqrs-separate-stores.png" class="img-fluid"
              alt=""/></div>
    <h4>Event Sourcing</h4>
    <p>Use an append-only store to record the full series of events that describe actions taken on data in a
        domain. Instead of storing just the current state of the data in a domain, use an append-only store to record
        the full series of actions taken on that data. The store acts as the system of record and can be used to
        materialize the domain objects. This can simplify tasks in complex domains, by avoiding the need to synchronize
        the data model and the business domain, while improving performance, scalability, and responsiveness. It can
        also provide consistency for transactional data, and maintain full audit trails and history that can enable
        compensating actions.</p>
    <p>Most applications work with data, and the typical approach is for the application to maintain the current state
        of the data by updating it as users work with it. For example, in the traditional create, read, update, and
        delete (CRUD) model a typical data process is to read data from the store, make some modifications to it, and
        update the current state of the data with the new values—often by using transactions that lock the data.</p>
    <div><img src="data/event-sourcing-overview.png" class="img-fluid" alt=""/>
    </div>
    <h4>External Configuration Store</h4>
    <p>Move configuration information out of the application deployment package to a centralized location. Move
        configuration information out of the application deployment package to a centralized location. This can provide
        opportunities for easier management and control of configuration data, and for sharing configuration data across
        applications and application instances.</p>
    <div><img src="data/external-configuration-store-overview.png" class="img-fluid" alt=""/>
    </div>
    <h4>Federated Identity</h4>
    <p>Delegate authentication to an external identity provider. Delegate authentication to an external identity
        provider. This can simplify development, minimize the requirement for user administration, and improve the user
        experience of the application.</p>
    <div><img src="data/federated-identity-multitenant.png" class="img-fluid" alt=""/></div>
    <h4>Gatekeeper</h4>
    <p>Protect applications and services by using a dedicated host instance that acts as a broker between clients and
        the application or service, validates and sanitizes requests, and passes requests and data between them. Protect
        applications and services by using a dedicated host instance that acts as a broker between clients and the
        application or service, validates and sanitizes requests, and passes requests and data between them. This can
        provide an additional layer of security, and limit the attack surface of the system.</p>
    <div><img src="data/gatekeeper-diagram.png" class="img-fluid" alt=""/></div>
    <div><img src="data/gatekeeper-endpoint.png" class="img-fluid" alt=""/></div>
    <h4>Gateway Aggregation</h4>
    <p>Use a gateway to aggregate multiple individual requests into a single request. This pattern is useful when a
        client must make multiple calls to different backend systems to perform an operation. To perform a single task,
        a client may have to make multiple calls to various backend services. An application that relies on many
        services to perform a task must expend resources on each request. When any new feature or service is added to
        the application, additional requests are needed, further increasing resource requirements and network calls.
        This chattiness between a client and a backend can adversely impact the performance and scale of the
        application. Microservice architectures have made this problem more common, as applications built around many
        smaller services naturally have a higher amount of cross-service calls.
    </p>
    <div><img src="data/gateway-aggregation.png" class="img-fluid" alt=""/></div>
    <h4>Gateway Offloading</h4>
    <p>Offload shared or specialized service functionality to a gateway proxy. This pattern can simplify application
        development by moving shared service functionality, such as the use of SSL certificates, from other parts of the
        application into the gateway.
    </p>
    <p>Some features are commonly used across multiple services, and these features require configuration, management,
        and maintenance. A shared or specialized service that is distributed with every application deployment increases
        the administrative overhead and increases the likelihood of deployment error. Any updates to a shared feature
        must be deployed across all services that share that feature.
    </p>
    <div><img src="data/gateway-offload.png" class="img-fluid" alt=""/></div>
    <h4>Health endpoint</h4>
    <p>Implement functional checks in an application that external tools can access through exposed endpoints at regular
        intervals. This can help to verify that applications and services are performing correctly. It's a good
        practice, and often a business requirement, to monitor web applications and back-end services, to ensure they're
        available and performing correctly. However, it's more difficult to monitor services running in the cloud than
        it is to monitor on-premises services. For example, you don't have full control of the hosting environment, and
        the services typically depend on other services provided by platform vendors and others.
    </p>
    <h4>Index Table</h4>
    <p>Create indexes over the fields in data stores that are frequently referenced by queries. Create indexes over the
        fields in data stores that are frequently referenced by queries. This pattern can improve query performance by
        allowing applications to more quickly locate the data to retrieve from a data store.</p>
    <div><img src="data/index-table.png" class="img-fluid" alt=""/></div>
    <h4>Leader Election</h4>
    <p>Coordinate the actions performed by a collection of collaborating instances in a distributed application by
        electing one instance as the leader that assumes responsibility for managing the others. This can help to ensure
        that instances don't conflict with each other, cause contention for shared resources, or inadvertently interfere
        with the work that other instances are performing.</p>
    <p>A single task instance should be elected to act as the leader, and this instance should coordinate the actions of
        the other subordinate task instances. If all of the task instances are running the same code, they are each
        capable of acting as the leader. Therefore, the election process must be managed carefully to prevent two or
        more instances taking over the leader role at the same time.</p>
    <p>The system must provide a robust mechanism for selecting the leader. This method has to cope with events such as
        network outages or process failures. In many solutions, the subordinate task instances monitor the leader
        through some type of heartbeat method, or by polling. If the designated leader terminates unexpectedly, or a
        network failure makes the leader unavailable to the subordinate task instances, it's necessary for them to elect
        a new leader.</p>
    <h4>MapReduce</h4>
    <p>A MapReduce program is composed of a map procedure, which performs filtering and sorting (such as sorting
        students by first name into queues, one queue for each name), and a reduce method, which performs a summary
        operation (such as counting the number of students in each queue, yielding name frequencies). The "MapReduce
        System" (also called "infrastructure" or "framework") orchestrates the processing by marshalling the distributed
        servers, running the various tasks in parallel, managing all communications and data transfers between the
        various parts of the system, and providing for redundancy and fault tolerance.</p>
    <div><img src="data/mapreduce.png" class="img-fluid" alt=""/></div>
    <h4>Materialized View</h4>
    <p>Generate prepopulated views over the data in one or more data stores when the data isn't ideally formatted for
        required query operations. This can help support efficient querying and data extraction, and improve application
        performance.</p>
    <p>To support efficient querying, a common solution is to generate, in advance, a view that materializes the data in
        a format suited to the required results set. The Materialized View pattern describes generating prepopulated
        views of data in environments where the source data isn't in a suitable format for querying, where generating a
        suitable query is difficult, or where query performance is poor due to the nature of the data or the data
        store.</p>
    <div><img src="data/materialized-view-pattern-diagram.png" class="img-fluid" alt=""/></div>
    <h4>Pipes & Filters</h4>
    <p>Decompose a task that performs complex processing into a series of separate elements that can be reused. This can
        improve performance, scalability, and reusability by allowing task elements that perform the processing to be
        deployed and scaled independently.</p>
    <p>Break down the processing required for each stream into a set of separate components (or filters), each
        performing a single task. By standardizing the format of the data that each component receives and sends, these
        filters can be combined together into a pipeline. This helps to avoid duplicating code, and makes it easy to
        remove, replace, or integrate additional components if the processing requirements change. The next figure shows
        a solution implemented using pipes and filters.</p>
    <div><img src="data/pipes-and-filters-solution.png" class="img-fluid" alt=""/></div>

    <h4>Priority Queue</h4>
    <p>Prioritize requests sent to services so that requests with a higher priority are received and processed more
        quickly than those with a lower priority. This pattern is useful in applications that offer different service
        level guarantees to individual clients.
    </p>
    <p>A queue is usually a first-in, first-out (FIFO) structure, and consumers typically receive messages in the same
        order that they were posted to the queue. However, some message queues support priority messaging. The
        application posting a message can assign a priority and the messages in the queue are automatically reordered so
        that those with a higher priority will be received before those with a lower priority. The figure illustrates a
        queue with priority messaging.
    </p>
    <div><img src="data/priority-queue-separate.png" class="img-fluid" alt=""/></div>
    <h4>Publisher-Subscriber</h4>
    <p>Enable an application to announce events to multiple interested consumers asynchronously, without coupling the
        senders to the receivers. Also called: Pub/sub messaging.</p>
    <p>Asynchronous messaging is an effective way to decouple senders from consumers, and avoid blocking the sender to
        wait for a response. However, using a dedicated message queue for each consumer does not effectively scale to
        many consumers. Also, some of the consumers might be interested in only a subset of the information. How can the
        sender announce events to all interested consumers without knowing their identities?</p>
    <div><img src="data/publish-subscribe.png" class="img-fluid" alt=""/></div>
    <h4>Queue-Based Load Leveling</h4>
    <p>Use a queue that acts as a buffer between a task and a service it invokes in order to smooth intermittent heavy
        loads that can cause the service to fail or the task to time out. This can help to minimize the impact of peaks
        in demand on availability and responsiveness for both the task and the service.</p>
    <p>Refactor the solution and introduce a queue between the task and the service. The task and the service run
        asynchronously. The task posts a message containing the data required by the service to a queue. The queue acts
        as a buffer, storing the message until it's retrieved by the service. The service retrieves the messages from
        the queue and processes them. Requests from a number of tasks, which can be generated at a highly variable rate,
        can be passed to the service through the same message queue. This figure shows using a queue to level the load
        on a service.</p>
    <div><img src="data/queue-based-load-leveling-pattern.png" class="img-fluid" alt=""/></div>
    <div><img src="data/queue-based-load-leveling-function.png" class="img-fluid" alt=""/></div>
    <h4>Retry</h4>
    <p>Enable an application to handle transient failures when it tries to connect to a service or network resource, by
        transparently retrying a failed operation. This can improve the stability of the application. An application
        that communicates with elements running in the cloud has to be sensitive to the transient faults that can occur
        in this environment. Faults include the momentary loss of network connectivity to components and services, the
        temporary unavailability of a service, or timeouts that occur when a service is busy. These faults are typically
        self-correcting, and if the action that triggered a fault is repeated after a suitable delay it's likely to be
        successful. For example, a database service that's processing a large number of concurrent requests can
        implement a throttling strategy that temporarily rejects any further requests until its workload has eased. An
        application trying to access the database might fail to connect, but if it tries again after a delay it might
        succeed.</p>
    <div><img src="data/retry-pattern.png" class="img-fluid" alt=""/></div>
    <h4>Scheduler Agent Supervisor</h4>
    <p>Coordinate a set of distributed actions as a single operation. If any of the actions fail, try to handle the
        failures transparently, or else undo the work that was performed, so the entire operation succeeds or fails as a
        whole. This can add resiliency to a distributed system, by enabling it to recover and retry actions that fail
        due to transient exceptions, long-lasting faults, and process failures.</p>
    <p>An application performs tasks that include a number of steps, some of which might invoke remote services or
        access remote resources. The individual steps might be independent of each other, but they are orchestrated by
        the application logic that implements the task. Whenever possible, the application should ensure that the task
        runs to completion and resolve any failures that might occur when accessing remote services or resources.
        Failures can occur for many reasons. For example, the network might be down, communications could be
        interrupted, a remote service might be unresponsive or in an unstable state, or a remote resource might be
        temporarily inaccessible, perhaps due to resource constraints. In many cases the failures will be transient and
        can be handled by using the Retry pattern. If the application detects a more permanent fault it can't easily
        recover from, it must be able to restore the system to a consistent state and ensure integrity of the entire
        operation.
    </p>
    <p>The Scheduler Agent Supervisor pattern defines the following actors. These actors orchestrate the steps to be
        performed as part of the overall task.</p>
    <div><img src="data/scheduler-agent-supervisor-pattern.png" class="img-fluid" alt=""/></div>
    <h4>Sequential Convoy</h4>
    <p>Process a set of related messages in a defined order, without blocking processing of other groups of
        messages.</p>
    <p>Applications often need to process a sequence of messages in the order they arrive, while still being able to
        scale out to handle increased load. In a distributed architecture, processing these messages in order is not
        straightforward, because the workers can scale independently and often pull messages independently, using a
        Competing Consumers pattern.</p>
    <p>For example, an order tracking system receives a ledger containing orders and the relevant operations on those
        orders. These operations could be to create an order, add a transaction to the order, modify a past transaction,
        or delete an order. In this system, operations must be performed in a first-in-first-out (FIFO) manner, but only
        at the order level. However, the initial queue receives a ledger containing transactions for many orders, which
        may be interleaved.
    </p>
    <p>Push related messages into categories within the queuing system, and have the queue listeners lock and pull only
        from one category, one message at a time.</p>
    <div><img src="data/sequential-convoy-overall.png" class="img-fluid" alt=""/></div>
    <h4>Sharding</h4>
    <p>Divide a data store into a set of horizontal partitions or shards. This can improve scalability when storing and
        accessing large volumes of data.
    </p>
    <p>A data store hosted by a single server might be subject to the following limitations:</p>
    <ul>
        <li><b>Storage space</b>. A data store for a large-scale cloud application is expected to contain a huge volume
            of data
            that could increase significantly over time. A server typically provides only a finite amount of disk
            storage, but you can replace existing disks with larger ones, or add further disks to a machine as data
            volumes grow. However, the system will eventually reach a limit where it isn't possible to easily increase
            the storage capacity on a given server.
        </li>

        <li><b>Computing resources</b>. A cloud application is required to support a large number of concurrent users,
            each of
            which run queries that retrieve information from the data store. A single server hosting the data store
            might not be able to provide the necessary computing power to support this load, resulting in extended
            response times for users and frequent failures as applications attempting to store and retrieve data time
            out. It might be possible to add memory or upgrade processors, but the system will reach a limit when it
            isn't possible to increase the compute resources any further.
        </li>

        <li><b>Network bandwidth</b>. Ultimately, the performance of a data store running on a single server is governed
            by the
            rate the server can receive requests and send replies. It's possible that the volume of network traffic
            might exceed the capacity of the network used to connect to the server, resulting in failed requests.
        </li>

        <li><b>Geography</b>. It might be necessary to store data generated by specific users in the same region as
            those users
            for legal, compliance, or performance reasons, or to reduce latency of data access. If the users are
            dispersed across different countries or regions, it might not be possible to store the entire data for the
            application in a single data store.
        </li>
    </ul>
    <p>Divide the data store into horizontal partitions or shards. Each shard has the same schema, but holds its own
        distinct subset of the data. A shard is a data store in its own right (it can contain the data for many entities
        of different types), running on a server acting as a storage node.</p>
    <div><img src="data/sharding-tenant.png" class="img-fluid" alt=""/></div>
    <p>The three main sharding strategies strategies:</p>
    <ul>
        <li>Lookup</li>
        <li>Range</li>
        <li>Hash</li>
    </ul>
    <h4>Sidecar</h4>
    <p>Deploy components of an application into a separate process or container to provide isolation and encapsulation.
        This pattern can also enable applications to be composed of heterogeneous components and technologies. This
        pattern is named Sidecar because it resembles a sidecar attached to a motorcycle. In the pattern, the sidecar is
        attached to a parent application and provides supporting features for the application. The sidecar also shares
        the same lifecycle as the parent application, being created and retired alongside the parent. The sidecar
        pattern is sometimes referred to as the sidekick pattern and is a decomposition pattern.
    </p>
    <p>Co-locate a cohesive set of tasks with the primary application, but place them inside their own process or
        container, providing a homogeneous interface for platform services across languages. A sidecar service is not
        necessarily part of the application, but is connected to it. It goes wherever the parent application goes.
        Sidecars are supporting processes or services that are deployed with the primary application. On a motorcycle,
        the sidecar is attached to one motorcycle, and each motorcycle can have its own sidecar. In the same way, a
        sidecar service shares the fate of its parent application. For each instance of the application, an instance of
        the sidecar is deployed and hosted alongside it.
    </p>
    <h4>Static Content Hosting</h4>
    <p>Deploy static content to a cloud-based storage service that can deliver them directly to the client. This can
        reduce the need for potentially expensive compute instances.</p>
    <p>Web applications typically include some elements of static content. This static content might include HTML pages
        and other resources such as images and documents that are available to the client, either as part of an HTML
        page (such as inline images, style sheets, and client-side JavaScript files) or as separate downloads (such as
        PDF documents). Although web servers are optimized for dynamic rendering and output caching, they still have to
        handle requests to download static content. This consumes processing cycles that could often be put to better
        use.
    </p>
    <p>In most cloud hosting environments, you can put some of an application's resources and static pages in a storage
        service. The storage service can serve requests for these resources, reducing load on the compute resources that
        handle other web requests. The cost for cloud-hosted storage is typically much less than for compute instances.
        When hosting some parts of an application in a storage service, the main considerations are related to
        deployment of the application and to securing resources that aren't intended to be available to anonymous users.
    </p>
    <div><img src="data/static-content-hosting-pattern.png" class="img-fluid" alt=""/></div>
    <h4>Strangler</h4>
    <p>Incrementally migrate a legacy system by gradually replacing specific pieces of functionality with new
        applications and services. As features from the legacy system are replaced, the new system eventually replaces
        all of the old system's features, strangling the old system and allowing you to decommission it.</p>
    <p>Incrementally replace specific pieces of functionality with new applications and services. Create a façade that
        intercepts requests going to the backend legacy system. The façade routes these requests either to the legacy
        application or the new services. Existing features can be migrated to the new system gradually, and consumers
        can continue using the same interface, unaware that any migration has taken place.
    </p>
    <div><img src="data/strangler.png" class="img-fluid" alt=""/></div>
    <h4>Throttling</h4>
    <p>Control the consumption of resources used by an instance of an application, an individual tenant, or an entire
        service. This can allow the system to continue to function and meet service level agreements, even when an
        increase in demand places an extreme load on resources.</p>
    <p>An alternative strategy to autoscaling is to allow applications to use resources only up to a limit, and then
        throttle them when this limit is reached. The system should monitor how it's using resources so that, when usage
        exceeds the threshold, it can throttle requests from one or more users. This will enable the system to continue
        functioning and meet any service level agreements (SLAs) that are in place. For more information on monitoring
        resource usage, see the Instrumentation and Telemetry Guidance.</p>
    <div><img src="data/throttling-multi-tenant.png" class="img-fluid" alt=""/></div>

    <h4>Valet Key</h4>
    <p>Use a token that provides clients with restricted direct access to a specific resource, in order to offload data
        transfer from the application. This is particularly useful in applications that use cloud-hosted storage systems
        or queues, and can minimize cost and maximize scalability and performance.</p>
    <p>You need to resolve the problem of controlling access to a data store where the store can't manage authentication
        and authorization of clients. One typical solution is to restrict access to the data store’s public connection
        and provide the client with a key or token that the data store can validate.</p>
    <div><img src="data/valet-key-pattern.png" class="img-fluid" alt=""/></div>
    <hr/>
    <h3>Enterprise Integration Patterns</h3>
    <p>https://camel.apache.org/components/latest/eips/enterprise-integration-patterns.html</p>
    <h2>Architectural pattern</h2>
    <ul>
        <li>ETL (data extraction transformation and loading)
            <ul>
                <li>Change data capture</li>
                <li>Near real-time ETL</li>
                <li>Batch ETL</li>
                <li>Data discovery</li>
            </ul>
            <br/>
            <ul>
                <li>Error handling</li>
                <li>Job scheduling</li>
                <li>Data validation</li>
                <li>Slowly changing dimensions load</li>
            </ul>
            <br/>
            <ul>
                <li>EAI</li>
                <li>Master data hub</li>
                <li>Operational data store (ODS)</li>
                <li>Data mart</li>
                <li>Data warehouse</li>
            </ul>
        </li>
        <li>
            Data architecture
            <ul>
                <li>Transaction data stores (TDS/OLTP)</li>
                <li>Master data store</li>
                <li>Operational data store</li>
                <li>Data mart</li>
                <li>Data warehouse</li>
            </ul>
            <br/>
            <ul>
                <li>Custom applications databases</li>
                <li>Packaged application databases</li>
            </ul>
            <br/>
            <ul>
                <li>ETL</li>
                <li>EAI</li>
                <li>SOA</li>
            </ul>
            <br/>
        </li>
    </ul>
    <div><img src="data/data-mart-wh.jpg" class="img-fluid" alt=""/></div>
    <h2>SOLID and GRASP</h2>
    <p>
        <b>SOLID</b>
    <ul>
        <li>Single responsibility principle</li>
        <li>Open/closed principle</li>
        <li>Liskov substitution principle</li>
        <li>Interface segregation principle</li>
        <li>Dependency inversion principle</li>
    </ul>
    </p>
    <p>
        <b>GRASP</b> (General Responsibility Assignment Software Patterns)
    </p>
</div>

<script>hljs.initHighlightingOnLoad();</script>
<!-- Yandex.Metrika counter -->
<script type="text/javascript"> (function (d, w, c) {
    (w[c] = w[c] || []).push(function () {
        try {
            w.yaCounter41245659 = new Ya.Metrika2({
                id: 41245659,
                clickmap: true,
                trackLinks: true,
                accurateTrackBounce: true,
                webvisor: true,
                trackHash: true
            });
        } catch (e) {
        }
    });
    var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () {
        n.parentNode.insertBefore(s, n);
    };
    s.type = "text/javascript";
    s.async = true;
    s.src = "https://mc.yandex.ru/metrika/tag.js";
    if (w.opera == "[object Opera]") {
        d.addEventListener("DOMContentLoaded", f, false);
    } else {
        f();
    }
})(document, window, "yandex_metrika_callbacks2"); </script>
<noscript>
    <div><img src="https://mc.yandex.ru/watch/41245659" style="position:absolute; left:-9999px;" alt=""/></div>
</noscript> <!-- /Yandex.Metrika counter -->
</body>
</html>
