<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Object-oriented programming, Introduction</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.2/css/bootstrap.min.css"
          integrity="sha384-Smlep5jCw/wG7hdkwQ/Z5nLIefveQRIY9nfy6xoR1uRYBtpZgI6339F5dgvm/e9B" crossorigin="anonymous">
    <meta name="google-site-verification" content="nKBS68MBglsXyUBNGGsQ7oQZU53wrBmnye0L6Fu4jBU"/>
    <script src="https://browser.sentry-cdn.com/4.6.5/bundle.min.js" crossorigin="anonymous"></script>
    <script type="text/javascript">Sentry.init({dsn: 'https://802d42edef034b74860743196de2cac2@sentry.io/1423759'});</script>
    <link rel="stylesheet"
          href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/default.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
    <link rel="apple-touch-icon" sizes="144x144" href="/upload/img/icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/upload/img/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/upload/img/icons/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/upload/img/icons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-TileImage" content="/upload/img/icons/mstile-144x144.png">
    <meta name="theme-color" content="#ffffff">
</head>
<body>
<div class="container">
    <div class="py-5 text-center">
        <h1>Object-oriented programming, Introduction</h1>
    </div>
</div>
<hr/>
<div class="container">
    <h2>UML</h2>
    <p>A UML diagram is a graphical representation of part of a model, typically showing a number of elements connected
        by relationships. Diagrams are one of the most expressive and appealing views of the repository; the diagram has
        a name and type and is typically constructed for a particular audience to convey an idea or to create a
        narrative description of part of the model. Diagrams can also be used to generate useful system artifacts such
        as XML schemas, database schemas, programming code and more. [<a
                href="https://sparxsystems.com/enterprise_architect_user_guide/15.1/model_domains/umldiagrams.html">ref</a>]
    </p>
    <hr/>
    <h3>Structural Models</h3>
    <h3>Class diagram</h3>
    <p>The Class diagram captures the logical structure of the system - the Classes - and things that make up the model.
        It is a static model, describing what exists and what attributes and behavior it has, rather than how something
        is done. On a Class diagram you can illustrate relationships between Classes and Interfaces using
        Generalizations, Aggregations and Associations, which are valuable in reflecting inheritance, composition or
        usage, and connections respectively.</p>
    <div><img src="data/cls-diagram.png" class="img-fluid" alt=""/></div>
    <h3>Composite Structure</h3>
    <p>A Composite Structure diagram reflects the internal collaboration of Classes, Interfaces or Components (and their
        properties) to describe a functionality. Composite Structure diagrams are similar to Class diagrams, but whilst
        Class diagrams model a static view of Class structures, including their attributes and behaviors, Composite
        Structure diagrams model a specific usage of the structure. You can use them to express run-time architectures,
        usage patterns and the participating elements' relationships, which might not be reflected by static
        diagrams.</p>
    <div><img src="data/cm-struct.png" class="img-fluid" alt=""/></div>
    <h3>Component</h3>
    <p>A Component diagram has a higher level of abstraction than a Class diagram; usually a component is implemented by
        one or more Classes (or Objects) at runtime. They are building blocks, built up so that eventually a component
        can encompass a large portion of a system.</p>
    <div><img src="data/cm.png" class="img-fluid" alt=""/></div>
    <h3>Deployment</h3>
    <p>A Deployment diagram shows how and where the system is to be deployed; that is, its execution architecture.</p>
    <div><img src="data/deploy.png" class="img-fluid" alt=""/></div>
    <hr/>
    <h2>Behavioral</h2>
    <h3>Use Case</h3>
    <p>Use Case diagrams capture Use Cases and the relationships between Actors and the subject (system).</p>
    <div><img src="data/usecase.png" class="img-fluid" alt=""/></div>
    <h3>StateMachines</h3>
    <p>StateMachines illustrate how an element (often a Class) can move between States, classifying its behavior
        according to transition triggers and constraining guards.</p>
    <div><img src="data/state.png" class="img-fluid" alt=""/></div>
    <h3>Sequence</h3>
    <p>A Sequence diagram is a structured representation of behavior as a series of sequential steps over time.</p>
    <div><img src="data/sequence.png" class="img-fluid" alt=""/></div>
    <h3>Communication</h3>
    <p>A Communication diagram is a diagram that shows the interactions between elements at run-time in much the same
        manner as a Sequence diagram. However, Communication diagrams are used to visualize inter-object relationships,
        while Sequence diagrams are more effective at visualizing processing over time.</p>
    <div><img src="data/communication.png" class="img-fluid" alt=""/></div>
    <hr/>
    <h2>Patterns</h2>
    <hr/>
    <h3>Creational patterns</h3>
    <ul>
        <li>Abstract factory</li>
        <li>Builder</li>
        <li>Dependency Injection</li>
        <li>Factory method</li>
        <li>Lazy initialization</li>
        <li>Multiton</li>
        <li>Object pool</li>
        <li>Prototype</li>
        <li>Singleton</li>
    </ul>
    <h4>Abstract factory</h4>
    <p>Provide an interface for creating families of related or dependent objects without specifying their concrete
        classes.</p>
    <div><img src="data/p-f.jpg" class="img-fluid" alt=""/></div>
    <hr/>
    <h4>Builder</h4>
    <p>Separate the construction of a complex object from its representation, allowing the same construction process to
        create various representations.</p>
    <div><img src="data/p-builder.png" class="img-fluid" alt=""/></div>
    <hr/>
    <h4>Dependency Injection</h4>
    <p>Separate the construction of a complex object from its representation, allowing the same construction process to
        create various representations.</p>
    <div><img src="data/p-di.jpg" class="img-fluid" alt=""/></div>
    <hr/>
    <h4>Factory method pattern</h4>
    <p>In class-based programming, the factory method pattern is a creational pattern that uses factory methods to deal
        with the problem of creating objects without having to specify the exact class of the object that will be
        created. This is done by creating objects by calling a factory method—either specified in an interface and
        implemented by child classes, or implemented in a base class and optionally overridden by derived classes—rather
        than by calling a constructor.</p>
    <div><img src="data/p-fm.jpg" class="img-fluid" alt=""/></div>
    <hr/>
    <h4>Lazy initialization</h4>
    <p>In computer programming, lazy initialization is the tactic of delaying the creation of an object, the calculation
        of a value, or some other expensive process until the first time it is needed. It is a kind of lazy evaluation
        that refers specifically to the instantiation of objects or other resources.</p>
    <hr/>
    <h4>Multiton pattern</h4>
    <p>In software engineering, the multiton pattern is a design pattern which generalizes the singleton pattern.
        Whereas the singleton allows only one instance of a class to be created, the multiton pattern allows for the
        controlled creation of multiple instances, which it manages through the use of a map.</p>
    <hr/>
    <h4>Object pool pattern</h4>
    <p>The object pool pattern is a software creational design pattern that uses a set of initialized objects kept ready
        to use – a "pool" – rather than allocating and destroying them on demand. A client of the pool will request an
        object from the pool and perform operations on the returned object. When the client has finished, it returns the
        object to the pool rather than destroying it; this can be done manually or automatically.</p>
    <hr/>
    <h4>Prototype</h4>
    <p>The prototype pattern is a creational design pattern in software development. It is used when the type of objects
        to create is determined by a prototypical instance, which is cloned to produce new objects.</p>
    <div><img src="data/f-proto.jpg" class="img-fluid" alt=""/></div>
    <hr/>
    <h4>Singleton</h4>
    <p>In software engineering, the singleton pattern is a software design pattern that restricts the instantiation of a
        class to one "single" instance. This is useful when exactly one object is needed to coordinate actions across
        the system. The term comes from the mathematical concept of a singleton.</p>
    <div><img src="data/p-singl.png" class="img-fluid" alt=""/></div>
    <hr/>
    <h3>Structural patterns</h3>
    <ul>
        <li>Adapter (Wrapper, Translator)</li>
        <li>Bridge</li>
        <li>Composite</li>
        <li>Decorator</li>
        <li>Facade</li>
        <li>Flyweight</li>
        <li>Front controller</li>
        <li>Marker</li>
        <li>Module</li>
        <li>Proxy</li>
        <li>Twin</li>
    </ul>
    <h4>Adapter</h4>
    <p>Converts one interface to another so that it matches what the client is expecting</p>
    <div><img src="data/p-adapter.jpg" class="img-fluid" alt=""/></div>
    <h4>Bridge</h4>
    <p>Decouple an abstraction from its implementation allowing the two to vary independently.</p>
    <div><img src="data/p-bridge.jpg" class="img-fluid" alt=""/></div>
    <h4>Composite</h4>
    <p>Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual
        objects and compositions of objects uniformly.</p>
    <div><img src="data/p-compose.jpg" class="img-fluid" alt=""/></div>
    <h4>Decorator</h4>
    <p>Dynamically adds responsibility to the interface by wrapping the original code. Attach additional
        responsibilities to an object dynamically keeping the same interface. Decorators provide a flexible alternative
        to subclassing for extending functionality. </p>
    <div><img src="data/p-decorator.jpg" class="img-fluid" alt=""/></div>
    <h4>Facade</h4>
    <p>Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that
        makes the subsystem easier to use.</p>
    <div><img src="data/p-facade.jpg" class="img-fluid" alt=""/></div>
    <h4>Flyweight</h4>
    <p>Use sharing to support large numbers of similar objects efficiently. A classic example usage of the flyweight
        pattern is the data structures for graphical representation of characters in a word processor. It might be
        desirable to have, for each character in a document, a glyph object containing its font outline, font metrics,
        and other formatting data, but this would amount to hundreds or thousands of bytes for each character. Instead,
        for every character there might be a reference to a flyweight glyph object shared by every instance of the same
        character in the document; only the position of each character (in the document and/or the page) would need to
        be stored internally.</p>
    <div><img src="data/f-flyweight.jpg" class="img-fluid" alt=""/></div>
    <h4>Front controller</h4>
    <p>The pattern relates to the design of Web applications. It provides a centralized entry point for handling
        requests.</p>
    <div><img src="data/p-fc.png" class="img-fluid" alt=""/></div>
    <h4>Marker</h4>
    <p>Empty interface to associate metadata with a class. An example of the application of marker interfaces from the
        Java programming language is the Serializable interface. </p>
    <h4>Module</h4>
    <p>Group several related elements, such as classes, singletons, methods, globally used, into a single conceptual
        entity. [<a href="https://www.oracle.com/corporate/features/understanding-java-9-modules.html">Java Modules</a>]
    </p>
    <h4>Proxy</h4>
    <p>Provide a surrogate or placeholder for another object to control access to it.</p>
    <div><img src="data/p-proxy.jpg" class="img-fluid" alt=""/></div>
    <h4>Twin</h4>
    <p>Twin allows modeling of multiple inheritance in programming languages that do not support this feature.</p>
    <div><img src="data/p-twin.png" class="img-fluid" alt=""/></div>

    <hr/>
    <h3>Behavioral patterns</h3>
    <ul>
        <li>Blackboard</li>
        <li>Chain of responsibility</li>
        <li>Command</li>
        <li>Interpreter</li>
        <li>Iterator</li>
        <li>Mediator</li>
        <li>Memento</li>
        <li>Null object</li>
        <li>Observer or Publish/subscribe</li>
        <li>Servant</li>
        <li>Specification</li>
        <li>State</li>
        <li>Strategy</li>
        <li>Template method</li>
        <li>Visitor</li>
    </ul>
    <h4>Blackboard</h4>
    <p>Artificial intelligence pattern for combining disparate sources of data (see blackboard system). That provides a
        computational framework for the design and implementation of systems that integrate large and diverse
        specialized modules, and implement complex, non-deterministic control strategies.</p>
    <div><img src="data/p-bb.png" class="img-fluid" alt=""/></div>
    <h4>Chain of responsibility</h4>
    <p>Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the
        request. Chain the receiving objects and pass the request along the chain until an object handles it.</p>
    <div><img src="data/f-cor.jpg" class="img-fluid" alt=""/></div>
    <h4>Command</h4>
    <p>Encapsulate a request as an object, thereby allowing for the parameterization of clients with different requests,
        and the queuing or logging of requests. It also allows for the support of undoable operations.</p>
    <div><img src="data/p-command.jpg" class="img-fluid" alt=""/></div>
    <h4>Interpreter</h4>
    <p>Given a language, define a representation for its grammar along with an interpreter that uses the representation
        to interpret sentences in the language. </p>
    <div><img src="data/p-inter.jpg" class="img-fluid" alt=""/></div>
    <h4>Iterator</h4>
    <p>Provide a way to access the elements of an aggregate object sequentially without exposing its underlying
        representation. </p>
    <div><img src="data/p-iter.jpg" class="img-fluid" alt=""/></div>
    <h4>Mediator</h4>
    <p>Define an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping
        objects from referring to each other explicitly, and it allows their interaction to vary independently.</p>
    <div><img src="data/m-mediator.jpg" class="img-fluid" alt=""/></div>
    <h4>Memento</h4>
    <p>Without violating encapsulation, capture and externalize an object's internal state allowing the object to be
        restored to this state later. The memento pattern is implemented with three objects: the originator, a caretaker
        and a memento. The originator is some object that has an internal state. The caretaker is going to do something
        to the originator, but wants to be able to undo the change. The caretaker first asks the originator for a
        memento object. Then it does whatever operation (or sequence of operations) it was going to do. To roll back to
        the state before the operations, it returns the memento object to the originator. The memento object itself is
        an opaque object (one which the caretaker cannot, or should not, change). When using this pattern, care should
        be taken if the originator may change other objects or resources - the memento pattern operates on a single
        object.</p>
    <div><img src="data/p-memento.jpg" class="img-fluid" alt=""/></div>
    <h4>Null object</h4>
    <p>Avoid null references by providing a default object. Null object is an object with no referenced value or with
        defined neutral ("null") behavior. </p>
    <h4>Observer</h4>
    <p>The subject, maintains a list of its dependents, called observers, and notifies them automatically of any state
        changes, usually by calling one of their methods. It is mainly used to implement distributed event handling
        systems, in "event driven" software. In those systems, the subject is usually called a "stream of events" or
        "stream source of events", while the observers are called "sink of events". The stream nomenclature simulates or
        adapts to a physical setup where the observers are physically separated and have no control over the emitted
        events of the subject/stream-source. This pattern then perfectly suits any process where data arrives through
        I/O, that is, where data is not available to the CPU at startup, but can arrive "randomly" (HTTP requests, GPIO
        data, user input from keyboard/mouse/..., distributed databases and blockchains, ...). Most modern languages
        have built-in "event" constructs which implement the observer pattern components. While not mandatory most
        'observers' implementations will use background threads listening for subject events and other support mechanism
        from the kernel (Linux epoll, ...)</p>
    <div><img src="data/p-obs.jpg" class="img-fluid" alt=""/></div>
    <h4>Publish/subscribe</h4>
    <p>Define a one-to-many dependency between objects where a state change in one object results in all its dependents
        being notified and updated automatically. Publish–subscribe is a messaging pattern where senders of messages,
        called publishers, do not program the messages to be sent directly to specific receivers, called subscribers,
        but instead categorize published messages into classes without knowledge of which subscribers, if any, there may
        be. Similarly, subscribers express interest in one or more classes and only receive messages that are of
        interest, without knowledge of which publishers, if any, there are.</p>
    <p>This pattern provides greater network scalability and a more dynamic network topology, with a resulting decreased
        flexibility to modify the publisher and the structure of the published data.</p>
    <h4>Servant</h4>
    <p>Define common functionality for a group of classes. The servant pattern is also frequently called helper class or
        utility class implementation for a given set of classes. The helper classes generally have no objects hence they
        have all static methods that act upon different kinds of class objects. A Servant is a class whose instance (or
        even just class) provides methods that take care of a desired service, while objects for which (or with whom)
        the servant does something, are taken as parameters.</p>
    <div><img src="data/p-servant.png" class="img-fluid" alt=""/></div>
    <h4>Specification</h4>
    <p>Recombinable business logic in a Boolean fashion. A specification pattern outlines a business rule that is
        combinable with other business rules. In this pattern, a unit of business logic inherits its functionality from
        the abstract aggregate Composite Specification class. The Composite Specification class has one function called
        IsSatisfiedBy that returns a boolean value. After instantiation, the specification is "chained" with other
        specifications, making new specifications easily maintainable, yet highly customizable business logic.
        Furthermore, upon instantiation the business logic may, through method invocation or inversion of control, have
        its state altered in order to become a delegate of other classes such as a persistence repository.</p>
    <div><img src="data/p-spec.png" class="img-fluid" alt=""/></div>
    <h4>State</h4>
    <p>Allow an object to alter its behavior when its internal state changes. The object will appear to change its
        class. The state pattern can be interpreted as a strategy pattern, which is able to switch a strategy through
        invocations of methods defined in the pattern's interface.</p>
    <div><img src="data/p-state.jpg" class="img-fluid" alt=""/></div>
    <h4>Strategy</h4>
    <p>Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm
        vary independently from clients that use it. Typically the strategy pattern stores a reference to some code in a
        data structure and retrieves it. This can be achieved by mechanisms such as the native function pointer, the
        first-class function, classes or class instances in object-oriented programming languages, or accessing the
        language implementation's internal storage of code via reflection.</p>
    <div><img src="data/p-strategy.jpg" class="img-fluid" alt=""/></div>
    <h4>Template method</h4>
    <p>Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template method lets
        subclasses redefine certain steps of an algorithm without changing the algorithm's structure. The helper methods
        may be either abstract methods, for which case subclasses are required to provide concrete implementations, or
        hook methods, which have empty bodies in the superclass. Subclasses can (but are not required to) customize the
        operation by overriding the hook methods. The intent of the template method is to define the overall structure
        of the operation, while allowing subclasses to refine, or redefine, certain steps.</p>
    <div><img src="data/p-template.jpg" class="img-fluid" alt=""/></div>
    <h4>Visitor</h4>
    <p>Represent an operation to be performed on the elements of an object structure. Visitor lets a new operation be
        defined without changing the classes of the elements on which it operates. In essence, the visitor allows adding
        new virtual functions to a family of classes, without modifying the classes. Instead, a visitor class is created
        that implements all of the appropriate specializations of the virtual function. The visitor takes the instance
        reference as input, and implements the goal through double dispatch.</p>
    <div><img src="data/p-visitor.jpg" class="img-fluid" alt=""/></div>
    <hr/>
    <h3>Functional</h3>
    <ul>
        <li>HOF (Higher-order function)</li>
        <li>Closure</li>
        <li>Generator</li>
    </ul>
    <h4>HOF (Higher-order function)</h4>
    <pre><code class="java">Function&lt;IntUnaryOperator, IntUnaryOperator&gt; twice = f -&gt; f.andThen(f);
twice.apply(x -&gt; x + 3).applyAsInt(7); // 13</code></pre>
    <h4>Closure</h4>
    <p>Closures are useful because they let you associate data (the lexical environment) with a function that operates
        on that data. This has obvious parallels to object-oriented programming, where objects allow you to associate
        data (the object's properties) with one or more methods.</p>
    <pre><code class="js">function makeSizer(size) {
  return function() {
    document.body.style.fontSize = size + 'px';
  };
}

var size12 = makeSizer(12);
var size14 = makeSizer(14);
var size16 = makeSizer(16);</code></pre>
    <h4>Generator</h4>
    <p>A generator is very similar to a function that returns an array, in that a generator has parameters, can be
        called, and generates a sequence of values. However, instead of building an array containing all the values and
        returning them all at once, a generator yields the values one at a time, which requires less memory and allows
        the caller to get started processing the first few values immediately. In short, a generator looks like a
        function but behaves like an iterator.</p>
    <pre><code class="java">public Iterable&lt;Integer&gt; fibonacci(int limit){
    return IntStream.generate(new IntSupplier() {
        int a = 1, b = 2;

        public int getAsInt() {
            int temp = a;
            a = b;
            b = a + temp;
            return temp;
        }
    }).limit(limit).boxed()::iterator;
}

// this could then be used as...
for (int f: fibonacci(10)) {
    System.out.println(f);
}</code></pre>
    <hr/>
    <h3>Concurrency patterns</h3>
    <p>https://en.wikipedia.org/wiki/Pattern-Oriented_Software_Architecture</p>
    <p>https://docs.oracle.com/javase/tutorial/essential/concurrency/index.html</p>
    <ul>
        <li>Active Object</li>
        <li>Balking</li>
        <li>Actor</li>
        <li>Barrier</li>
        <li>Coroutine</li>
        <li>Binding properties</li>
        <li>Fiber</li>
        <li>Futex</li>
        <li>Futures and promises</li>
        <li>Compute kernel</li>
        <li>Double-checked locking</li>
        <li>Event-based asynchronous</li>
        <li>Guarded suspension</li>
        <li>Join</li>
        <li>Lock</li>
        <li>Messaging design pattern (MDP)</li>
        <li>Monitor object</li>
        <li>Reactor</li>
        <li>Read-write lock</li>
        <li>Scheduler</li>
        <li>Thread pool</li>
        <li>Thread-specific storage</li>
        <li>Immutable object</li>
        <li>Nuclear</li>
        <li>Proactor</li>
        <li>STM (Software transactional memory)</li>
    </ul>
    <h4>Active Object</h4>
    <p>Decouples method execution from method invocation that reside in their own thread of control. The goal is to
        introduce concurrency, by using asynchronous method invocation and a scheduler for handling requests.</p>
    <div>
        The pattern consists of six elements:

        <ul>
            <li>A proxy, which provides an interface towards clients with publicly accessible methods.</li>
            <li>An interface which defines the method request on an active object.</li>
            <li>A list of pending requests from clients.</li>
            <li>A scheduler, which decides which request to execute next.</li>
            <li>The implementation of the active object method.</li>
            <li>A callback or variable for the client to receive the result.</li>
        </ul>
    </div>
    <h4>Balking</h4>
    <p>Only execute an action on an object when the object is in a particular state. For example, if an object reads ZIP
        files and a calling method invokes a get method on the object when the ZIP file is not open, the object would
        "balk" at the request. In the Java programming language, for example, an IllegalStateException might be thrown
        under these circumstances.</p>
    <pre><code class="java">public class Example {
    private boolean jobInProgress = false;

    public void job() {
        synchronized(this) {
            if (jobInProgress) {
                return;
            }
            jobInProgress = true;
        }
        // Code to execute job goes here
        // ...
        jobCompleted();
    }

    void jobCompleted() {
        synchronized(this) {
            jobInProgress = false;
        }
    }
}</code></pre>
    <h4>Actor</h4>
    <p>The actor model adopts the philosophy that everything is an actor. This is similar to the everything is an object
        philosophy used by some object-oriented programming languages. An actor is a computational entity that, in
        response to a message it receives, can concurrently:</p>
    <ul>
        <li>send a finite number of messages to other actors;</li>
        <li>create a finite number of new actors;</li>
        <li>designate the behavior to be used for the next message it receives.</li>
        <li>There is no assumed sequence to the above actions and they could be carried out in parallel.</li>
    </ul>
    <h4>Binding properties</h4>
    <p>Combining multiple observers to force properties in different objects to be synchronized or coordinated in some
        way. As an alternative to the aspect-oriented implementation of mutual properties, property binding can be
        proposed.</p>
    <pre><code>bind_multiple_one_way(src_obj, src_prop, dst_objs[], dst_props[])
{
  for (i, j) in (dst_objs, dst_props)
  {
    bind_properties_one_way(src_obj, src_prop, i, j);
  }
}

// In this pseudo-code are not taken into the account initial values assignments
bind_two_way(prop1, prop2)
{
  bind(prop1, prop2);
  bind(prop2, prop1);
}


on_property_change(src_prop, dst_prop)
{
  block_signal(src_obj, on_property_change);
  dst_prop := src_prop;
  unblock_signal(src_obj, on_property_change);
}</code></pre>

    <h4>Compute kernel</h4>
    <p>In computing, a compute kernel is a routine compiled for high throughput accelerators (such as graphics
        processing units (GPUs), digital signal processors (DSPs) or field-programmable gate arrays (FPGAs)), separate
        from but used by a main program (typically running on a central processing unit). They are sometimes called
        compute shaders, sharing execution units with vertex shaders and pixel shaders on GPUs, but are not limited to
        execution on one class of device, or graphics APIs. Compute kernels roughly correspond to inner loops when
        implementing algorithms in traditional languages (except there is no implied sequential operation), or to code
        passed to internal iterators.</p>

    <h4>Double-checked locking</h4>
    <p>Reduce the overhead of acquiring a lock by first testing the locking criterion (the 'lock hint') in an unsafe
        manner; only if that succeeds does the actual locking logic proceed. Can be unsafe when implemented in some
        language/hardware combinations. It can therefore sometimes be considered an anti-pattern.</p>
    <pre><code class="java">// Single-threaded version
class Foo {
    private Helper helper;
    public Helper getHelper() {
        if (helper == null) {
            helper = new Helper();
        }
        return helper;
    }

    // other functions and members...
}

class Foo {
    private volatile Helper helper;
    public Helper getHelper() {
        Helper localRef = helper;
        if (localRef == null) {
            synchronized (this) {
                localRef = helper;
                if (localRef == null) {
                    helper = localRef = new Helper();
                }
            }
        }
        return localRef;
    }

    // other functions and members...
}</code></pre>
    <h4>Event-based asynchronous</h4>
    <p>Addresses problems with the asynchronous pattern that occur in multithreaded programs. Asynchronous pattern is a
        design pattern in which the call site is not blocked while waiting for the called code to finish. Instead, the
        calling thread is notified when the reply arrives. Polling for a reply is an undesired option. FutureTask class
        in Java use events to solve the same problem. This pattern is a variant of AMI whose implementation carries more
        overhead, but it is useful for objects representing software components.</p>
    <h4>Guarded suspension</h4>
    <p>Manages operations that require both a lock to be acquired and a precondition to be satisfied before the
        operation can be executed. The guarded suspension pattern is typically applied to method calls in
        object-oriented programs, and involves suspending the method call, and the calling thread, until the
        precondition (acting as a guard) is satisfied. Because it is blocking, the guarded suspension pattern is
        generally only used when the developer knows that a method call will be suspended for a finite and reasonable
        period of time. If a method call is suspended for too long, then the overall program will slow down or stop,
        waiting for the precondition to be satisfied. If the developer knows that the method call suspension will be
        indefinite or for an unacceptably long period, then the balking pattern may be preferred.</p>
    <pre><code>public class Example {
    synchronized void guardedMethod() {
        while (!preCondition()) {
            try {
                // Continue to wait
                wait();
                // …
            } catch (InterruptedException e) {
                // …
            }
        }
        // Actual task implementation
    }
    synchronized void alterObjectStateMethod() {
        // Change the object state
        // …
        // Inform waiting threads
        notify();
    }
}</code></pre>
    <h4>Join</h4>
    <p>Join-pattern provides a way to write concurrent, parallel and distributed programs by message passing. Compared
        to the use of threads and locks, this is a high-level programming model. This template is based on join-calculus
        and uses pattern matching. Concretely, this is done by allowing the join definition of several functions and/or
        channels by matching concurrent call and messages patterns. It is a type of concurrency pattern because it makes
        easier and more flexible for these entities to communicate and deal with the multi-threaded programming
        paradigm. [<a href="https://en.wikipedia.org/wiki/Join-pattern">ref</a>]</p>
    <p>Join-pattern in classic programming literature:</p>
    <ul>
        <li>Barriers</li>
        <li>Dining philosophers problem</li>
        <li>Mutual exclusion</li>
        <li>Reader-writer locking</li>
        <li>Semaphores</li>
    </ul>
    <h4>Lock</h4>
    <p>One thread puts a "lock" on a resource, preventing other threads from accessing or modifying it. Java provides
        the keyword synchronized to lock code blocks, methods or objects and libraries featuring concurrency-safe data
        structures.</p>
    <h4>Messaging design pattern (MDP)</h4>
    <p>Allows the interchange of information (i.e. messages) between components and applications. In telecommunications,
        a message exchange pattern (MEP) describes the pattern of messages required by a communications protocol to
        establish or use a communication channel. There are two major message exchange patterns — a request–response
        pattern, and a one-way pattern. For example, HTTP is a request–response pattern protocol, and UDP is a one-way
        pattern.</p>
    <h4>Monitor object</h4>
    <p>An object whose methods are subject to mutual exclusion, thus preventing multiple objects from erroneously trying
        to use it at the same time. Monitor is a synchronization construct that allows threads to have both mutual
        exclusion and the ability to wait (block) for a certain condition to become false. Monitors also have a
        mechanism for signaling other threads that their condition has been met. A monitor consists of a mutex (lock)
        object and condition variables. A condition variable essentially is a container of threads that are waiting for
        a certain condition. Monitors provide a mechanism for threads to temporarily give up exclusive access in order
        to wait for some condition to be met, before regaining exclusive access and resuming their task.</p>
    <pre><code>public void addName(String name) {
    synchronized(this) {
        lastName = name;
        nameCount++;
    }
    nameList.add(name);
}</code></pre>
    <h4>Reactor</h4>
    <p>A reactor object provides an asynchronous interface to resources that must be handled synchronously. The service
        handler then demultiplexes the incoming requests and dispatches them synchronously to the associated request
        handlers. </p>
    <h4>Read-write lock</h4>
    <p>Allows concurrent read access to an object, but requires exclusive access for write operations.An RW lock allows
        concurrent access for read-only operations, while write operations require exclusive access. This means that
        multiple threads can read the data in parallel but an exclusive lock is needed for writing or modifying data.
        When a writer is writing the data, all other writers or readers will be blocked until the writer is finished
        writing. A common use might be to control access to a data structure in memory that cannot be updated atomically
        and is invalid (and should not be read by another thread) until the update is complete.</p>
    <pre><code class="java">class CachedData {
   Object data;
   volatile boolean cacheValid;
   final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();

   void processCachedData() {
     rwl.readLock().lock();
     if (!cacheValid) {
        // Must release read lock before acquiring write lock
        rwl.readLock().unlock();
        rwl.writeLock().lock();
        try {
          // Recheck state because another thread might have
          // acquired write lock and changed state before we did.
          if (!cacheValid) {
            data = ...
            cacheValid = true;
          }
          // Downgrade by acquiring read lock before releasing write lock
          rwl.readLock().lock();
        } finally {
          rwl.writeLock().unlock(); // Unlock write, still hold read
        }
     }

     try {
       use(data);
     } finally {
       rwl.readLock().unlock();
     }
   }
 }</code></pre>
    <h4>Stamped Lock</h4>
    <p>A capability-based lock with three modes for controlling read/write access. The state of a StampedLock consists
        of a version and mode. Lock acquisition methods return a stamp that represents and controls access with respect
        to a lock state; "try" versions of these methods may instead return the special value zero to represent failure
        to acquire access. Lock release and conversion methods require stamps as arguments, and fail if they do not
        match the state of the lock. The three modes are:</p>
    <ul>
        <li>Writing. Method writeLock() possibly blocks waiting for exclusive access, returning a stamp that can be used
            in method unlockWrite(long) to release the lock. Untimed and timed versions of tryWriteLock are also
            provided. When the lock is held in write mode, no read locks may be obtained, and all optimistic read
            validations will fail.
        </li>
        <li>Reading. Method readLock() possibly blocks waiting for non-exclusive access, returning a stamp that can be
            used in method unlockRead(long) to release the lock. Untimed and timed versions of tryReadLock are also
            provided.
        </li>
        <li>Optimistic Reading. Method tryOptimisticRead() returns a non-zero stamp only if the lock is not currently
            held in write mode. Method validate(long) returns true if the lock has not been acquired in write mode since
            obtaining a given stamp. This mode can be thought of as an extremely weak version of a read-lock, that can
            be broken by a writer at any time. The use of optimistic mode for short read-only code segments often
            reduces contention and improves throughput. However, its use is inherently fragile. Optimistic read sections
            should only read fields and hold them in local variables for later use after validation. Fields read while
            in optimistic mode may be wildly inconsistent, so usage applies only when you are familiar enough with data
            representations to check consistency and/or repeatedly invoke method validate(). For example, such steps are
            typically required when first reading an object or array reference, and then accessing one of its fields,
            elements or methods.
        </li>
    </ul>
    <p>StampedLocks are designed for use as internal utilities in the development of thread-safe components. Their use
        relies on knowledge of the internal properties of the data, objects, and methods they are protecting. They are
        not reentrant, so locked bodies should not call other unknown methods that may try to re-acquire locks (although
        you may pass a stamp to other methods that can use or convert it). The use of read lock modes relies on the
        associated code sections being side-effect-free. Unvalidated optimistic read sections cannot call methods that
        are not known to tolerate potential inconsistencies. Stamps use finite representations, and are not
        cryptographically secure (i.e., a valid stamp may be guessable). Stamp values may recycle after (no sooner than)
        one year of continuous operation. A stamp held without use or validation for longer than this period may fail to
        validate correctly. StampedLocks are serializable, but always deserialize into initial unlocked state, so they
        are not useful for remote locking.</p>
    <pre><code class="java"> class Point {
   private double x, y;
   private final StampedLock sl = new StampedLock();

   void move(double deltaX, double deltaY) { // an exclusively locked method
     long stamp = sl.writeLock();
     try {
       x += deltaX;
       y += deltaY;
     } finally {
       sl.unlockWrite(stamp);
     }
   }

   double distanceFromOrigin() { // A read-only method
     long stamp = sl.tryOptimisticRead();
     double currentX = x, currentY = y;
     if (!sl.validate(stamp)) {
        stamp = sl.readLock();
        try {
          currentX = x;
          currentY = y;
        } finally {
           sl.unlockRead(stamp);
        }
     }
     return Math.sqrt(currentX * currentX + currentY * currentY);
   }

   void moveIfAtOrigin(double newX, double newY) { // upgrade
     // Could instead start with optimistic, not read mode
     long stamp = sl.readLock();
     try {
       while (x == 0.0 && y == 0.0) {
         long ws = sl.tryConvertToWriteLock(stamp);
         if (ws != 0L) {
           stamp = ws;
           x = newX;
           y = newY;
           break;
         }
         else {
           sl.unlockRead(stamp);
           stamp = sl.writeLock();
         }
       }
     } finally {
       sl.unlock(stamp);
     }
   }
 }</code></pre>
    <h4>Scheduler</h4>
    <p>Explicitly control when threads may execute single-threaded code. A scheduler is what carries out the scheduling
        activity. Schedulers are often implemented so they keep all computer resources busy (as in load balancing),
        allow multiple users to share system resources effectively, or to achieve a target quality of service.
        Scheduling is fundamental to computation itself, and an intrinsic part of the execution model of a computer
        system; the concept of scheduling makes it possible to have computer multitasking with a single central
        processing unit (CPU).</p>
    <h4>Thread pool</h4>
    <p>A number of threads are created to perform a number of tasks, which are usually organized in a queue. Typically,
        there are many more tasks than threads. Can be considered a special case of the object pool pattern.Often also
        called a replicated workers or worker-crew model, a thread pool maintains multiple threads waiting for tasks to
        be allocated for concurrent execution by the supervising program. By maintaining a pool of threads, the model
        increases performance and avoids latency in execution due to frequent creation and destruction of threads for
        short-lived tasks. The number of available threads is tuned to the computing resources available to the program,
        such as a parallel task queue after completion of execution.</p>
    <h4>Thread-specific storage</h4>
    <p>Static or "global" memory local to a thread. While the use of global variables is generally discouraged in modern
        programming, legacy operating systems such as UNIX are designed for uniprocessor hardware and require some
        additional mechanism to retain the semantics of pre-reentrant APIs. An example of such situations is where
        functions use a global variable to set an error condition (for example the global variable errno used by many
        functions of the C library). If errno were a global variable, a call of a system function on one thread may
        overwrite the value previously set by a call of a system function on a different thread, possibly before
        following code on that different thread could check for the error condition. The solution is to have errno be a
        variable that looks like it is global, but in fact exists once per thread—i.e., it lives in thread-local
        storage. A second use case would be multiple threads accumulating information into a global variable. To avoid a
        race condition, every access to this global variable would have to be protected by a mutex. Alternatively, each
        thread might accumulate into a thread-local variable (that, by definition, cannot be read from or written to
        from other threads, implying that there can be no race conditions). Threads then only have to synchronise a
        final accumulation from their own thread-local variable into a single, truly global variable.</p>
    <pre><code class="java">private static final ThreadLocal&lt;Integer&gt; myThreadLocalInteger = new ThreadLocal&lt;&gt;();</code></pre>
    <h4>Immutable object</h4>
    <p>Strings and other concrete objects are typically expressed as immutable objects to improve readability and
        runtime efficiency in object-oriented programming. Immutable objects are also useful because they are inherently
        thread-safe. This is in contrast to a mutable object (changeable object), which can be modified after it is
        created. In some cases, an object is considered immutable even if some internally used attributes change, but
        the object's state appears unchanging from an external point of view. For example, an object that uses
        memoization to cache the results of expensive computations could still be considered an immutable object. Other
        benefits are that they are simpler to understand and reason about and offer higher security than mutable
        objects. A classic example of an immutable object is an instance of the Java String class.</p>
    <h4>Proactor</h4>
    <p>Proactor is a software design pattern for event handling in which long running activities are running in an
        asynchronous part. A completion handler is called after the asynchronous part has terminated. The proactor
        pattern can be considered to be an asynchronous variant of the synchronous reactor pattern.</p>
    <div><img src="data/p-proactor.png" class="img-fluid" alt=""/></div>
    <h4>STM (Software transactional memory)</h4>
    <p>In computer science, software transactional memory (STM) is a concurrency control mechanism analogous to database
        transactions for controlling access to shared memory in concurrent computing. It is an alternative to lock-based
        synchronization. STM is a strategy implemented in software, rather than as a hardware component. A transaction
        in this context occurs when a piece of code executes a series of reads and writes to shared memory. </p>
    <h4>Barrier</h4>
    <p>In parallel computing, a barrier is a type of synchronization method. A barrier for a group of threads or
        processes in the source code means any thread/process must stop at this point and cannot proceed until all other
        threads/processes reach this barrier.</p>
    <h4>Coroutine</h4>
    <p>Coroutines are computer program components that generalize subroutines for non-preemptive multitasking, by
        allowing execution to be suspended and resumed. Coroutines are well-suited for implementing familiar program
        components such as cooperative tasks, exceptions, event loops, iterators, infinite lists and pipes.</p>
    <p>Kotlin example:</p>
    <pre><code class="kotlin">suspend fun main() = coroutineScope {
    launch {
       delay(1000)
       println("Kotlin Coroutines World!")
    }
    println("Hello")
}</code></pre>
    <h4>Futures and promises</h4>
    <p>In computer science, future, promise, delay, and deferred refer to constructs used for synchronizing program
        execution in some concurrent programming languages. They describe an object that acts as a proxy for a result
        that is initially unknown, usually because the computation of its value is not yet complete.</p>
    <p>Java example:</p>
    <pre><code class="java">public class SquareCalculator {

    private ExecutorService executor
      = Executors.newSingleThreadExecutor();

    public Future&lt;Integer&gt; calculate(Integer input) {
        return executor.submit(() -> {
            Thread.sleep(1000);
            return input * input;
        });
    }
}</code></pre>

    <hr/>
    <h3>Architectural</h3>
    <ul>
        <li>Layers</li>
        <li>Pipes & filters</li>
        <li>Broker</li>
        <li>MVC</li>
        <li>Presentation-Abstraction-Control</li>
    </ul>
    <h4>Layers</h4>
    <p>In object-oriented design, a layer is a group of classes that have the same set of link-time module dependencies
        to other modules.In other words, a layer is a group of reusable components that are reusable in similar
        circumstances. In programming languages, the layer distinction is often expressed as "import" dependencies
        between software modules. The most common architecture pattern is the layered architecture pattern, otherwise
        known as the n-tier architecture pattern. This pattern is the de facto standard for most Java EE applications
        and therefore is widely known by most architects, designers, and developers. The layered architecture pattern
        closely matches the traditional IT communication and organizational structures found in most companies, making
        it a natural choice for most business application development efforts. [<a
                href="https://www.oreilly.com/library/view/software-architecture-patterns/9781491971437/ch01.html">ref</a>]
    </p>
    <div><img src="data/layers.png" class="img-fluid" alt=""/></div>
    <h4>Event-Driven Architecture</h4>
    <p>The event-driven architecture pattern is a popular distributed asynchronous architecture pattern used to produce
        highly scalable applications. It is also highly adaptable and can be used for small applications and as well as
        large, complex ones. The event-driven architecture is made up of highly decoupled, single-purpose event
        processing components that asynchronously receive and process events.</p>
    <div><img src="data/events.png" class="img-fluid" alt=""/></div>
    <h4>Microkernel Architecture</h4>
    <p>The microkernel architecture pattern (sometimes referred to as the plug-in architecture pattern) is a natural
        pattern for implementing product-based applications. A product-based application is one that is packaged and
        made available for download in versions as a typical third-party product. However, many companies also develop
        and release their internal business applications like software products, complete with versions, release notes,
        and pluggable features. These are also a natural fit for this pattern. The microkernel architecture pattern
        allows you to add additional application features as plug-ins to the core application, providing extensibility
        as well as feature separation and isolation.</p>
    <div><img src="data/mk.png" class="img-fluid" alt=""/></div>

    <hr/>
    <h3>Cloud Distributed</h3>
    <ul>
        <li>Ambassador</li>
        <li>Anti-Corruption Layer</li>
        <li>Bulkhead</li>
        <li>Cache-Aside</li>
        <li>Circuit Breaker</li>
        <li>CQRS</li>
        <li>Compensating Transaction</li>
        <li>Competing Consumers</li>
        <li>Compute Resource Consolidation</li>
        <li>Event Sourcing</li>
        <li>External Configuration Store</li>
        <li>Federated Identity</li>
        <li>Gatekeeper</li>
        <li>Index Table</li>
        <li>Leader Election</li>
        <li>MapReduce</li>
        <li>Materialized View</li>
        <li>Pipes</li>
        <li>Filters</li>
        <li>Priority</li>
        <li> Queue</li>
        <li>Publisher-Subscriber</li>
        <li>Queue-Based Load Leveling</li>
        <li>Retry</li>
        <li>Scheduler Agent Supervisor</li>
        <li>Sharding</li>
        <li>Sidecar</li>
        <li>Strangler</li>
        <li>Throttling</li>
        <li>Valet Key</li>
    </ul>
    <p>https://en.wikipedia.org/wiki/Software_design_pattern</p>
    <hr/>
    <h3>Enterprise Integration Patterns</h3>
    <p>https://camel.apache.org/components/latest/eips/enterprise-integration-patterns.html</p>
    <h2>Architectural pattern</h2>
    <ul>
        <li>ETL (data extraction transformation and loading)
            <ul>
                <li>Change data capture</li>
                <li>Near real-time ETL</li>
                <li>Batch ETL</li>
                <li>Data discovery</li>
            </ul>
            <br/>
            <ul>
                <li>Error handling</li>
                <li>Job scheduling</li>
                <li>Data validation</li>
                <li>Slowly changing dimensions load</li>
            </ul>
            <br/>
            <ul>
                <li>EAI</li>
                <li>Master data hub</li>
                <li>Operational data store (ODS)</li>
                <li>Data mart</li>
                <li>Data warehouse</li>
            </ul>
        </li>
        <li>
            Data architecture
            <ul>
                <li>Transaction data stores (TDS/OLTP)</li>
                <li>Master data store</li>
                <li>Operational data store</li>
                <li>Data mart</li>
                <li>Data warehouse</li>
            </ul>
            <br/>
            <ul>
                <li>Custom applications databases</li>
                <li>Packaged application databases</li>
            </ul>
            <br/>
            <ul>
                <li>ETL</li>
                <li>EAI</li>
                <li>SOA</li>
            </ul>
            <br/>
        </li>
    </ul>
    <div><img src="data/data-mart-wh.jpg" class="img-fluid" alt=""/></div>
    <h2>SOLID and GRASP</h2>
    <p>
        <b>SOLID</b>
    <ul>
        <li>Single responsibility principle</li>
        <li>Open/closed principle</li>
        <li>Liskov substitution principle</li>
        <li>Interface segregation principle</li>
        <li>Dependency inversion principle</li>
    </ul>
    </p>
    <p>
        <b>GRASP</b> (General Responsibility Assignment Software Patterns)
    </p>
</div>

<script>hljs.initHighlightingOnLoad();</script>
<!-- Yandex.Metrika counter -->
<script type="text/javascript"> (function (d, w, c) {
    (w[c] = w[c] || []).push(function () {
        try {
            w.yaCounter41245659 = new Ya.Metrika2({
                id: 41245659,
                clickmap: true,
                trackLinks: true,
                accurateTrackBounce: true,
                webvisor: true,
                trackHash: true
            });
        } catch (e) {
        }
    });
    var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () {
        n.parentNode.insertBefore(s, n);
    };
    s.type = "text/javascript";
    s.async = true;
    s.src = "https://mc.yandex.ru/metrika/tag.js";
    if (w.opera == "[object Opera]") {
        d.addEventListener("DOMContentLoaded", f, false);
    } else {
        f();
    }
})(document, window, "yandex_metrika_callbacks2"); </script>
<noscript>
    <div><img src="https://mc.yandex.ru/watch/41245659" style="position:absolute; left:-9999px;" alt=""/></div>
</noscript> <!-- /Yandex.Metrika counter -->
</body>
</html>
